<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Analysis of single cell RNA-seq data</title>
  <meta name="description" content="Analysis of single cell RNA-seq data">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="Analysis of single cell RNA-seq data" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Analysis of single cell RNA-seq data" />
  
  
  

<meta name="author" content="Vladimir Kiselev (wikiselev), Tallulah Andrews, Davis McCarthy (davisjmcc), Maren Büttner (marenbuettner) and Martin Hemberg (m_hemberg)">


<meta name="date" content="2017-10-28">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="construction-of-expression-matrix.html">
<link rel="next" href="seurat-chapter.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<!-- for Facebook -->  
<meta property="og:url" content="http://hemberg-lab.github.io/scRNA.seq.course/" />
<meta property="og:description" content="In this course we will be surveying the existing problems as well as the available computational and statistical frameworks available for the analysis of scRNA-seq. The course is taught through the University of Cambridge Bioinformatics training unit, but the material found on these pages is meant to be used for anyone interested in learning about computational analysis of scRNA-seq data." />
<meta property="og:image" content="http://hemberg-lab.github.io/scRNA.seq.course/figures/RNA-Seq_workflow-5.pdf.jpg" />

<!-- for Twitter -->          
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="Analysis of single-cell RNA-seq data" />
<meta name="twitter:description" content="In this course we will be surveying the existing problems as well as the available computational and statistical frameworks available for the analysis of scRNA-seq. The course is taught through the University of Cambridge Bioinformatics training unit, but the material found on these pages is meant to be used for anyone interested in learning about computational analysis of scRNA-seq data." />
<meta name="twitter:image" content="http://hemberg-lab.github.io/scRNA.seq.course/figures/RNA-Seq_workflow-5.pdf.jpg" />

<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71525309-1', 'auto');
  ga('send', 'pageview');

</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="index.html">Table of Contents</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> About the course</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#video"><i class="fa fa-check"></i><b>1.1</b> Video</a></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#registration"><i class="fa fa-check"></i><b>1.2</b> Registration</a></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#github"><i class="fa fa-check"></i><b>1.3</b> GitHub</a></li>
<li class="chapter" data-level="1.4" data-path="index.html"><a href="index.html#r-based"><i class="fa fa-check"></i><b>1.4</b> R-based</a></li>
<li class="chapter" data-level="1.5" data-path="index.html"><a href="index.html#docker-image-rstudio"><i class="fa fa-check"></i><b>1.5</b> Docker image (RStudio)</a></li>
<li class="chapter" data-level="1.6" data-path="index.html"><a href="index.html#manual-installation"><i class="fa fa-check"></i><b>1.6</b> Manual installation</a></li>
<li class="chapter" data-level="1.7" data-path="index.html"><a href="index.html#license"><i class="fa fa-check"></i><b>1.7</b> License</a></li>
<li class="chapter" data-level="1.8" data-path="index.html"><a href="index.html#prerequisites"><i class="fa fa-check"></i><b>1.8</b> Prerequisites</a></li>
<li class="chapter" data-level="1.9" data-path="index.html"><a href="index.html#contact"><i class="fa fa-check"></i><b>1.9</b> Contact</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html"><i class="fa fa-check"></i><b>2</b> Introduction to single-cell RNA-seq</a><ul>
<li class="chapter" data-level="2.1" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#bulk-rna-seq"><i class="fa fa-check"></i><b>2.1</b> Bulk RNA-seq</a></li>
<li class="chapter" data-level="2.2" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#scrna-seq"><i class="fa fa-check"></i><b>2.2</b> scRNA-seq</a></li>
<li class="chapter" data-level="2.3" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#workflow"><i class="fa fa-check"></i><b>2.3</b> Workflow</a></li>
<li class="chapter" data-level="2.4" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#computational-analysis"><i class="fa fa-check"></i><b>2.4</b> Computational Analysis</a></li>
<li class="chapter" data-level="2.5" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#challenges"><i class="fa fa-check"></i><b>2.5</b> Challenges</a></li>
<li class="chapter" data-level="2.6" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#experimental-methods"><i class="fa fa-check"></i><b>2.6</b> Experimental methods</a></li>
<li class="chapter" data-level="2.7" data-path="introduction-to-single-cell-rna-seq.html"><a href="introduction-to-single-cell-rna-seq.html#what-platform-to-use-for-my-experiment"><i class="fa fa-check"></i><b>2.7</b> What platform to use for my experiment?</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html"><i class="fa fa-check"></i><b>3</b> Construction of expression matrix</a><ul>
<li class="chapter" data-level="3.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#reads-qc"><i class="fa fa-check"></i><b>3.1</b> Reads QC</a></li>
<li class="chapter" data-level="3.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#reads-alignment"><i class="fa fa-check"></i><b>3.2</b> Reads alignment</a></li>
<li class="chapter" data-level="3.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#alignment-example"><i class="fa fa-check"></i><b>3.3</b> Alignment example</a></li>
<li class="chapter" data-level="3.4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#mapping-qc"><i class="fa fa-check"></i><b>3.4</b> Mapping QC</a></li>
<li class="chapter" data-level="3.5" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#reads-quantification"><i class="fa fa-check"></i><b>3.5</b> Reads quantification</a></li>
<li class="chapter" data-level="3.6" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#umichapter"><i class="fa fa-check"></i><b>3.6</b> Unique Molecular Identifiers (UMIs)</a><ul>
<li class="chapter" data-level="3.6.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#introduction"><i class="fa fa-check"></i><b>3.6.1</b> Introduction</a></li>
<li class="chapter" data-level="3.6.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#mapping-barcodes"><i class="fa fa-check"></i><b>3.6.2</b> Mapping Barcodes</a></li>
<li class="chapter" data-level="3.6.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#counting-barcodes"><i class="fa fa-check"></i><b>3.6.3</b> Counting Barcodes</a></li>
<li class="chapter" data-level="3.6.4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#correcting-for-errors"><i class="fa fa-check"></i><b>3.6.4</b> Correcting for Errors</a></li>
<li class="chapter" data-level="3.6.5" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#downstream-analysis"><i class="fa fa-check"></i><b>3.6.5</b> Downstream Analysis</a></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#bioconductor-singlecellexperiment-and-scater"><i class="fa fa-check"></i><b>3.7</b> Bioconductor, <code>SingleCellExperiment</code> and <code>scater</code></a><ul>
<li class="chapter" data-level="3.7.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#bioconductor"><i class="fa fa-check"></i><b>3.7.1</b> Bioconductor</a></li>
<li class="chapter" data-level="3.7.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#singlecellexperiment-class"><i class="fa fa-check"></i><b>3.7.2</b> <code>SingleCellExperiment</code> class</a></li>
<li class="chapter" data-level="3.7.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#scater-package"><i class="fa fa-check"></i><b>3.7.3</b> <code>scater</code> package</a></li>
</ul></li>
<li class="chapter" data-level="3.8" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#exprs-qc"><i class="fa fa-check"></i><b>3.8</b> Expression QC (UMI)</a><ul>
<li class="chapter" data-level="3.8.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#introduction-1"><i class="fa fa-check"></i><b>3.8.1</b> Introduction</a></li>
<li class="chapter" data-level="3.8.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#tung-dataset"><i class="fa fa-check"></i><b>3.8.2</b> Tung dataset</a></li>
<li class="chapter" data-level="3.8.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#cell-qc"><i class="fa fa-check"></i><b>3.8.3</b> Cell QC</a></li>
<li class="chapter" data-level="3.8.4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#cell-filtering"><i class="fa fa-check"></i><b>3.8.4</b> Cell filtering</a></li>
<li class="chapter" data-level="3.8.5" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#compare-filterings"><i class="fa fa-check"></i><b>3.8.5</b> Compare filterings</a></li>
<li class="chapter" data-level="3.8.6" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#gene-analysis"><i class="fa fa-check"></i><b>3.8.6</b> Gene analysis</a></li>
<li class="chapter" data-level="3.8.7" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#save-the-data"><i class="fa fa-check"></i><b>3.8.7</b> Save the data</a></li>
<li class="chapter" data-level="3.8.8" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#big-exercise"><i class="fa fa-check"></i><b>3.8.8</b> Big Exercise</a></li>
<li class="chapter" data-level="3.8.9" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#sessioninfo"><i class="fa fa-check"></i><b>3.8.9</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="3.9" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#expression-qc-reads"><i class="fa fa-check"></i><b>3.9</b> Expression QC (Reads)</a></li>
<li class="chapter" data-level="3.10" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#data-visualization"><i class="fa fa-check"></i><b>3.10</b> Data visualization</a><ul>
<li class="chapter" data-level="3.10.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#introduction-2"><i class="fa fa-check"></i><b>3.10.1</b> Introduction</a></li>
<li class="chapter" data-level="3.10.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#visual-pca"><i class="fa fa-check"></i><b>3.10.2</b> PCA plot</a></li>
<li class="chapter" data-level="3.10.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#visual-tsne"><i class="fa fa-check"></i><b>3.10.3</b> tSNE map</a></li>
<li class="chapter" data-level="3.10.4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#big-exercise-1"><i class="fa fa-check"></i><b>3.10.4</b> Big Exercise</a></li>
<li class="chapter" data-level="3.10.5" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#sessioninfo-1"><i class="fa fa-check"></i><b>3.10.5</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="3.11" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#data-visualization-reads"><i class="fa fa-check"></i><b>3.11</b> Data visualization (Reads)</a><ul>
<li class="chapter" data-level="3.11.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#sessioninfo-2"><i class="fa fa-check"></i><b>3.11.1</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="3.12" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#identifying-confounding-factors"><i class="fa fa-check"></i><b>3.12</b> Identifying confounding factors</a><ul>
<li class="chapter" data-level="3.12.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#introduction-3"><i class="fa fa-check"></i><b>3.12.1</b> Introduction</a></li>
<li class="chapter" data-level="3.12.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#correlations-with-pcs"><i class="fa fa-check"></i><b>3.12.2</b> Correlations with PCs</a></li>
<li class="chapter" data-level="3.12.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#explanatory-variables"><i class="fa fa-check"></i><b>3.12.3</b> Explanatory variables</a></li>
<li class="chapter" data-level="3.12.4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#other-confounders"><i class="fa fa-check"></i><b>3.12.4</b> Other confounders</a></li>
<li class="chapter" data-level="3.12.5" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#exercise"><i class="fa fa-check"></i><b>3.12.5</b> Exercise</a></li>
<li class="chapter" data-level="3.12.6" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#sessioninfo-3"><i class="fa fa-check"></i><b>3.12.6</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="3.13" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#identifying-confounding-factors-reads"><i class="fa fa-check"></i><b>3.13</b> Identifying confounding factors (Reads)</a><ul>
<li class="chapter" data-level="3.13.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#sessioninfo-4"><i class="fa fa-check"></i><b>3.13.1</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="3.14" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#normalization-theory"><i class="fa fa-check"></i><b>3.14</b> Normalization theory</a><ul>
<li class="chapter" data-level="3.14.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#introduction-4"><i class="fa fa-check"></i><b>3.14.1</b> Introduction</a></li>
<li class="chapter" data-level="3.14.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#library-size-1"><i class="fa fa-check"></i><b>3.14.2</b> Library size</a></li>
<li class="chapter" data-level="3.14.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#normalisations"><i class="fa fa-check"></i><b>3.14.3</b> Normalisations</a></li>
</ul></li>
<li class="chapter" data-level="3.15" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#normalization-practice-umi"><i class="fa fa-check"></i><b>3.15</b> Normalization practice (UMI)</a><ul>
<li class="chapter" data-level="3.15.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#raw"><i class="fa fa-check"></i><b>3.15.1</b> Raw</a></li>
<li class="chapter" data-level="3.15.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#cpm"><i class="fa fa-check"></i><b>3.15.2</b> CPM</a></li>
<li class="chapter" data-level="3.15.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#tmm"><i class="fa fa-check"></i><b>3.15.3</b> TMM</a></li>
<li class="chapter" data-level="3.15.4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#scran"><i class="fa fa-check"></i><b>3.15.4</b> scran</a></li>
<li class="chapter" data-level="3.15.5" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#size-factor-rle"><i class="fa fa-check"></i><b>3.15.5</b> Size-factor (RLE)</a></li>
<li class="chapter" data-level="3.15.6" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#upperquantile"><i class="fa fa-check"></i><b>3.15.6</b> Upperquantile</a></li>
<li class="chapter" data-level="3.15.7" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#downsampling"><i class="fa fa-check"></i><b>3.15.7</b> Downsampling</a></li>
<li class="chapter" data-level="3.15.8" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#normalizing-for-genetranscript-length"><i class="fa fa-check"></i><b>3.15.8</b> Normalizing for gene/transcript length</a></li>
<li class="chapter" data-level="3.15.9" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#exercise-1"><i class="fa fa-check"></i><b>3.15.9</b> Exercise</a></li>
<li class="chapter" data-level="3.15.10" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#sessioninfo-5"><i class="fa fa-check"></i><b>3.15.10</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="3.16" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#normalization-practice-reads"><i class="fa fa-check"></i><b>3.16</b> Normalization practice (Reads)</a><ul>
<li class="chapter" data-level="3.16.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#sessioninfo-6"><i class="fa fa-check"></i><b>3.16.1</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="3.17" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#dealing-with-confounders"><i class="fa fa-check"></i><b>3.17</b> Dealing with confounders</a><ul>
<li class="chapter" data-level="3.17.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#introduction-5"><i class="fa fa-check"></i><b>3.17.1</b> Introduction</a></li>
<li class="chapter" data-level="3.17.2" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#remove-unwanted-variation"><i class="fa fa-check"></i><b>3.17.2</b> Remove Unwanted Variation</a></li>
<li class="chapter" data-level="3.17.3" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#combat"><i class="fa fa-check"></i><b>3.17.3</b> Combat</a></li>
<li class="chapter" data-level="3.17.4" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#mnncorrect"><i class="fa fa-check"></i><b>3.17.4</b> mnnCorrect</a></li>
<li class="chapter" data-level="3.17.5" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#glm"><i class="fa fa-check"></i><b>3.17.5</b> GLM</a></li>
<li class="chapter" data-level="3.17.6" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#effectiveness-1"><i class="fa fa-check"></i><b>3.17.6</b> Effectiveness 1</a></li>
<li class="chapter" data-level="3.17.7" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#effectiveness-2"><i class="fa fa-check"></i><b>3.17.7</b> Effectiveness 2</a></li>
<li class="chapter" data-level="3.17.8" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#effectiveness-3"><i class="fa fa-check"></i><b>3.17.8</b> Effectiveness 3</a></li>
<li class="chapter" data-level="3.17.9" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#effectiveness-4"><i class="fa fa-check"></i><b>3.17.9</b> Effectiveness 4</a></li>
<li class="chapter" data-level="3.17.10" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#exercise-2"><i class="fa fa-check"></i><b>3.17.10</b> Exercise</a></li>
<li class="chapter" data-level="3.17.11" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#sessioninfo-7"><i class="fa fa-check"></i><b>3.17.11</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="3.18" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#dealing-with-confounders-reads"><i class="fa fa-check"></i><b>3.18</b> Dealing with confounders (Reads)</a><ul>
<li class="chapter" data-level="3.18.1" data-path="construction-of-expression-matrix.html"><a href="construction-of-expression-matrix.html#remove-unwanted-variation-1"><i class="fa fa-check"></i><b>3.18.1</b> Remove Unwanted Variation</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="biological-analysis.html"><a href="biological-analysis.html"><i class="fa fa-check"></i><b>4</b> Biological Analysis</a><ul>
<li class="chapter" data-level="4.1" data-path="biological-analysis.html"><a href="biological-analysis.html#clustering-introduction"><i class="fa fa-check"></i><b>4.1</b> Clustering Introduction</a><ul>
<li class="chapter" data-level="4.1.1" data-path="biological-analysis.html"><a href="biological-analysis.html#introduction-6"><i class="fa fa-check"></i><b>4.1.1</b> Introduction</a></li>
<li class="chapter" data-level="4.1.2" data-path="biological-analysis.html"><a href="biological-analysis.html#dimensionality-reductions"><i class="fa fa-check"></i><b>4.1.2</b> Dimensionality reductions</a></li>
<li class="chapter" data-level="4.1.3" data-path="biological-analysis.html"><a href="biological-analysis.html#clustering-methods"><i class="fa fa-check"></i><b>4.1.3</b> Clustering methods</a></li>
<li class="chapter" data-level="4.1.4" data-path="biological-analysis.html"><a href="biological-analysis.html#challenges-in-clustering"><i class="fa fa-check"></i><b>4.1.4</b> Challenges in clustering</a></li>
<li class="chapter" data-level="4.1.5" data-path="biological-analysis.html"><a href="biological-analysis.html#tools-for-scrna-seq-data"><i class="fa fa-check"></i><b>4.1.5</b> Tools for scRNA-seq data</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="biological-analysis.html"><a href="biological-analysis.html#clust-methods"><i class="fa fa-check"></i><b>4.2</b> Clustering example</a><ul>
<li class="chapter" data-level="4.2.1" data-path="biological-analysis.html"><a href="biological-analysis.html#deng-dataset"><i class="fa fa-check"></i><b>4.2.1</b> Deng dataset</a></li>
<li class="chapter" data-level="4.2.2" data-path="biological-analysis.html"><a href="biological-analysis.html#sc3-1"><i class="fa fa-check"></i><b>4.2.2</b> SC3</a></li>
<li class="chapter" data-level="4.2.3" data-path="biological-analysis.html"><a href="biological-analysis.html#pcareduce-1"><i class="fa fa-check"></i><b>4.2.3</b> pcaReduce</a></li>
<li class="chapter" data-level="4.2.4" data-path="biological-analysis.html"><a href="biological-analysis.html#tsne-kmeans"><i class="fa fa-check"></i><b>4.2.4</b> tSNE + kmeans</a></li>
<li class="chapter" data-level="4.2.5" data-path="biological-analysis.html"><a href="biological-analysis.html#snn-cliq-1"><i class="fa fa-check"></i><b>4.2.5</b> SNN-Cliq</a></li>
<li class="chapter" data-level="4.2.6" data-path="biological-analysis.html"><a href="biological-analysis.html#sincera-1"><i class="fa fa-check"></i><b>4.2.6</b> SINCERA</a></li>
<li class="chapter" data-level="4.2.7" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-9"><i class="fa fa-check"></i><b>4.2.7</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="biological-analysis.html"><a href="biological-analysis.html#feature-selection"><i class="fa fa-check"></i><b>4.3</b> Feature Selection</a><ul>
<li class="chapter" data-level="4.3.1" data-path="biological-analysis.html"><a href="biological-analysis.html#identifying-genes-vs-a-null-model"><i class="fa fa-check"></i><b>4.3.1</b> Identifying Genes vs a Null Model</a></li>
<li class="chapter" data-level="4.3.2" data-path="biological-analysis.html"><a href="biological-analysis.html#correlated-expression"><i class="fa fa-check"></i><b>4.3.2</b> Correlated Expression</a></li>
<li class="chapter" data-level="4.3.3" data-path="biological-analysis.html"><a href="biological-analysis.html#comparing-methods"><i class="fa fa-check"></i><b>4.3.3</b> Comparing Methods</a></li>
<li class="chapter" data-level="4.3.4" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-10"><i class="fa fa-check"></i><b>4.3.4</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="biological-analysis.html"><a href="biological-analysis.html#pseudotime-analysis"><i class="fa fa-check"></i><b>4.4</b> Pseudotime analysis</a><ul>
<li class="chapter" data-level="4.4.1" data-path="biological-analysis.html"><a href="biological-analysis.html#tscan"><i class="fa fa-check"></i><b>4.4.1</b> TSCAN</a></li>
<li class="chapter" data-level="4.4.2" data-path="biological-analysis.html"><a href="biological-analysis.html#monocle"><i class="fa fa-check"></i><b>4.4.2</b> monocle</a></li>
<li class="chapter" data-level="4.4.3" data-path="biological-analysis.html"><a href="biological-analysis.html#diffusion-maps"><i class="fa fa-check"></i><b>4.4.3</b> Diffusion maps</a></li>
<li class="chapter" data-level="4.4.4" data-path="biological-analysis.html"><a href="biological-analysis.html#slicer"><i class="fa fa-check"></i><b>4.4.4</b> SLICER</a></li>
<li class="chapter" data-level="4.4.5" data-path="biological-analysis.html"><a href="biological-analysis.html#comparison-of-the-methods"><i class="fa fa-check"></i><b>4.4.5</b> Comparison of the methods</a></li>
<li class="chapter" data-level="4.4.6" data-path="biological-analysis.html"><a href="biological-analysis.html#expression-of-genes-through-time"><i class="fa fa-check"></i><b>4.4.6</b> Expression of genes through time</a></li>
<li class="chapter" data-level="4.4.7" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-11"><i class="fa fa-check"></i><b>4.4.7</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="biological-analysis.html"><a href="biological-analysis.html#imputation"><i class="fa fa-check"></i><b>4.5</b> Imputation</a><ul>
<li class="chapter" data-level="4.5.1" data-path="biological-analysis.html"><a href="biological-analysis.html#scimpute"><i class="fa fa-check"></i><b>4.5.1</b> scImpute</a></li>
<li class="chapter" data-level="4.5.2" data-path="biological-analysis.html"><a href="biological-analysis.html#magic"><i class="fa fa-check"></i><b>4.5.2</b> MAGIC</a></li>
<li class="chapter" data-level="4.5.3" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-12"><i class="fa fa-check"></i><b>4.5.3</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="4.6" data-path="biological-analysis.html"><a href="biological-analysis.html#dechapter"><i class="fa fa-check"></i><b>4.6</b> Differential Expression (DE) analysis</a><ul>
<li class="chapter" data-level="4.6.1" data-path="biological-analysis.html"><a href="biological-analysis.html#bulk-rna-seq-1"><i class="fa fa-check"></i><b>4.6.1</b> Bulk RNA-seq</a></li>
<li class="chapter" data-level="4.6.2" data-path="biological-analysis.html"><a href="biological-analysis.html#single-cell-rna-seq"><i class="fa fa-check"></i><b>4.6.2</b> Single cell RNA-seq</a></li>
<li class="chapter" data-level="4.6.3" data-path="biological-analysis.html"><a href="biological-analysis.html#differences-in-distribution"><i class="fa fa-check"></i><b>4.6.3</b> Differences in Distribution</a></li>
<li class="chapter" data-level="4.6.4" data-path="biological-analysis.html"><a href="biological-analysis.html#models-of-single-cell-rnaseq-data"><i class="fa fa-check"></i><b>4.6.4</b> Models of single-cell RNASeq data</a></li>
</ul></li>
<li class="chapter" data-level="4.7" data-path="biological-analysis.html"><a href="biological-analysis.html#de-in-a-real-dataset"><i class="fa fa-check"></i><b>4.7</b> DE in a real dataset</a><ul>
<li class="chapter" data-level="4.7.1" data-path="biological-analysis.html"><a href="biological-analysis.html#introduction-7"><i class="fa fa-check"></i><b>4.7.1</b> Introduction</a></li>
<li class="chapter" data-level="4.7.2" data-path="biological-analysis.html"><a href="biological-analysis.html#kolmogorov-smirnov-test"><i class="fa fa-check"></i><b>4.7.2</b> Kolmogorov-Smirnov test</a></li>
<li class="chapter" data-level="4.7.3" data-path="biological-analysis.html"><a href="biological-analysis.html#wilcoxmann-whitney-u-test"><i class="fa fa-check"></i><b>4.7.3</b> Wilcox/Mann-Whitney-U Test</a></li>
<li class="chapter" data-level="4.7.4" data-path="biological-analysis.html"><a href="biological-analysis.html#edger"><i class="fa fa-check"></i><b>4.7.4</b> edgeR</a></li>
<li class="chapter" data-level="4.7.5" data-path="biological-analysis.html"><a href="biological-analysis.html#monocle-1"><i class="fa fa-check"></i><b>4.7.5</b> Monocle</a></li>
<li class="chapter" data-level="4.7.6" data-path="biological-analysis.html"><a href="biological-analysis.html#mast"><i class="fa fa-check"></i><b>4.7.6</b> MAST</a></li>
<li class="chapter" data-level="4.7.7" data-path="biological-analysis.html"><a href="biological-analysis.html#slow-methods-1h-to-run"><i class="fa fa-check"></i><b>4.7.7</b> Slow Methods (&gt;1h to run)</a></li>
<li class="chapter" data-level="4.7.8" data-path="biological-analysis.html"><a href="biological-analysis.html#bpsc"><i class="fa fa-check"></i><b>4.7.8</b> BPSC</a></li>
<li class="chapter" data-level="4.7.9" data-path="biological-analysis.html"><a href="biological-analysis.html#scde"><i class="fa fa-check"></i><b>4.7.9</b> SCDE</a></li>
<li class="chapter" data-level="4.7.10" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-13"><i class="fa fa-check"></i><b>4.7.10</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="4.8" data-path="biological-analysis.html"><a href="biological-analysis.html#projecting-scrna-seq-data"><i class="fa fa-check"></i><b>4.8</b> Projecting scRNA-seq data</a><ul>
<li class="chapter" data-level="4.8.1" data-path="biological-analysis.html"><a href="biological-analysis.html#datasets"><i class="fa fa-check"></i><b>4.8.1</b> Datasets</a></li>
<li class="chapter" data-level="4.8.2" data-path="biological-analysis.html"><a href="biological-analysis.html#run-scmap"><i class="fa fa-check"></i><b>4.8.2</b> Run <code>scmap</code></a></li>
<li class="chapter" data-level="4.8.3" data-path="biological-analysis.html"><a href="biological-analysis.html#results"><i class="fa fa-check"></i><b>4.8.3</b> Results</a></li>
<li class="chapter" data-level="4.8.4" data-path="biological-analysis.html"><a href="biological-analysis.html#creating-a-precomputed-reference"><i class="fa fa-check"></i><b>4.8.4</b> Creating a precomputed Reference</a></li>
<li class="chapter" data-level="4.8.5" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-14"><i class="fa fa-check"></i><b>4.8.5</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="4.9" data-path="biological-analysis.html"><a href="biological-analysis.html#search-scrna-seq-data"><i class="fa fa-check"></i><b>4.9</b> Search scRNA-Seq data</a><ul>
<li class="chapter" data-level="4.9.1" data-path="biological-analysis.html"><a href="biological-analysis.html#about"><i class="fa fa-check"></i><b>4.9.1</b> About</a></li>
<li class="chapter" data-level="4.9.2" data-path="biological-analysis.html"><a href="biological-analysis.html#dataset"><i class="fa fa-check"></i><b>4.9.2</b> Dataset</a></li>
<li class="chapter" data-level="4.9.3" data-path="biological-analysis.html"><a href="biological-analysis.html#gene-index"><i class="fa fa-check"></i><b>4.9.3</b> Gene Index</a></li>
<li class="chapter" data-level="4.9.4" data-path="biological-analysis.html"><a href="biological-analysis.html#marker-genes"><i class="fa fa-check"></i><b>4.9.4</b> Marker genes</a></li>
<li class="chapter" data-level="4.9.5" data-path="biological-analysis.html"><a href="biological-analysis.html#search-cells-by-a-gene-list"><i class="fa fa-check"></i><b>4.9.5</b> Search cells by a gene list</a></li>
<li class="chapter" data-level="4.9.6" data-path="biological-analysis.html"><a href="biological-analysis.html#sessioninfo-15"><i class="fa fa-check"></i><b>4.9.6</b> sessionInfo()</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="seurat-chapter.html"><a href="seurat-chapter.html"><i class="fa fa-check"></i><b>5</b> <code>Seurat</code></a><ul>
<li class="chapter" data-level="5.1" data-path="seurat-chapter.html"><a href="seurat-chapter.html#seurat-object-class"><i class="fa fa-check"></i><b>5.1</b> <code>seurat</code> object class</a></li>
<li class="chapter" data-level="5.2" data-path="seurat-chapter.html"><a href="seurat-chapter.html#expression-qc"><i class="fa fa-check"></i><b>5.2</b> Expression QC</a></li>
<li class="chapter" data-level="5.3" data-path="seurat-chapter.html"><a href="seurat-chapter.html#normalization"><i class="fa fa-check"></i><b>5.3</b> Normalization</a></li>
<li class="chapter" data-level="5.4" data-path="seurat-chapter.html"><a href="seurat-chapter.html#highly-variable-genes-1"><i class="fa fa-check"></i><b>5.4</b> Highly variable genes</a></li>
<li class="chapter" data-level="5.5" data-path="seurat-chapter.html"><a href="seurat-chapter.html#dealing-with-confounders-1"><i class="fa fa-check"></i><b>5.5</b> Dealing with confounders</a></li>
<li class="chapter" data-level="5.6" data-path="seurat-chapter.html"><a href="seurat-chapter.html#linear-dimensionality-reduction"><i class="fa fa-check"></i><b>5.6</b> Linear dimensionality reduction</a></li>
<li class="chapter" data-level="5.7" data-path="seurat-chapter.html"><a href="seurat-chapter.html#significant-pcs"><i class="fa fa-check"></i><b>5.7</b> Significant PCs</a></li>
<li class="chapter" data-level="5.8" data-path="seurat-chapter.html"><a href="seurat-chapter.html#clustering-cells"><i class="fa fa-check"></i><b>5.8</b> Clustering cells</a></li>
<li class="chapter" data-level="5.9" data-path="seurat-chapter.html"><a href="seurat-chapter.html#marker-genes-1"><i class="fa fa-check"></i><b>5.9</b> Marker genes</a></li>
<li class="chapter" data-level="5.10" data-path="seurat-chapter.html"><a href="seurat-chapter.html#sessioninfo-16"><i class="fa fa-check"></i><b>5.10</b> sessionInfo()</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="ideal-scrnaseq-pipeline-as-of-mar-2017.html"><a href="ideal-scrnaseq-pipeline-as-of-mar-2017.html"><i class="fa fa-check"></i><b>6</b> “Ideal” scRNAseq pipeline (as of Mar 2017)</a><ul>
<li class="chapter" data-level="6.1" data-path="ideal-scrnaseq-pipeline-as-of-mar-2017.html"><a href="ideal-scrnaseq-pipeline-as-of-mar-2017.html#experimental-design"><i class="fa fa-check"></i><b>6.1</b> Experimental Design</a></li>
<li class="chapter" data-level="6.2" data-path="ideal-scrnaseq-pipeline-as-of-mar-2017.html"><a href="ideal-scrnaseq-pipeline-as-of-mar-2017.html#processing-reads"><i class="fa fa-check"></i><b>6.2</b> Processing Reads</a></li>
<li class="chapter" data-level="6.3" data-path="ideal-scrnaseq-pipeline-as-of-mar-2017.html"><a href="ideal-scrnaseq-pipeline-as-of-mar-2017.html#preparing-expression-matrix"><i class="fa fa-check"></i><b>6.3</b> Preparing Expression Matrix</a></li>
<li class="chapter" data-level="6.4" data-path="ideal-scrnaseq-pipeline-as-of-mar-2017.html"><a href="ideal-scrnaseq-pipeline-as-of-mar-2017.html#biological-interpretation"><i class="fa fa-check"></i><b>6.4</b> Biological Interpretation</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="advanced-exercises.html"><a href="advanced-exercises.html"><i class="fa fa-check"></i><b>7</b> Advanced exercises</a></li>
<li class="chapter" data-level="8" data-path="resources.html"><a href="resources.html"><i class="fa fa-check"></i><b>8</b> Resources</a><ul>
<li class="chapter" data-level="8.1" data-path="resources.html"><a href="resources.html#scrna-seq-protocols"><i class="fa fa-check"></i><b>8.1</b> scRNA-seq protocols</a></li>
<li class="chapter" data-level="8.2" data-path="resources.html"><a href="resources.html#external-rna-control-consortium-ercc"><i class="fa fa-check"></i><b>8.2</b> External RNA Control Consortium (ERCC)</a></li>
<li class="chapter" data-level="8.3" data-path="resources.html"><a href="resources.html#scrna-seq-analysis-tools"><i class="fa fa-check"></i><b>8.3</b> scRNA-seq analysis tools</a></li>
<li class="chapter" data-level="8.4" data-path="resources.html"><a href="resources.html#scrna-seq-public-datasets"><i class="fa fa-check"></i><b>8.4</b> scRNA-seq public datasets</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>9</b> References</a></li>
<li class="divider"></li>
<li><a href="http://www.sanger.ac.uk/science/groups/hemberg-group" target="blank">Hemberg Lab, 2017</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Analysis of single cell RNA-seq data</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="biological-analysis" class="section level1">
<h1><span class="header-section-number">4</span> Biological Analysis</h1>
<div id="clustering-introduction" class="section level2">
<h2><span class="header-section-number">4.1</span> Clustering Introduction</h2>
<p>Once we have normalized the data and removed confounders we can carry out analyses that are relevant to the biological questions at hand. The exact nature of the analysis depends on the dataset. Nevertheless, there are a few aspects that are useful in a wide range of contexts and we will be discussing some of them in the next few chapters. We will start with the clustering of scRNA-seq data.</p>
<div id="introduction-6" class="section level3">
<h3><span class="header-section-number">4.1.1</span> Introduction</h3>
<p>One of the most promising applications of scRNA-seq is <em>de novo</em> discovery and annotation of cell-types based on transcription profiles. Computationally, this is a hard problem as it amounts to <strong>unsupervised clustering</strong>. That is, we need to identify groups of cells based on the similarities of the transcriptomes without any prior knowledge of the labels. Moreover, in most situations we do not even know the number of clusters <em>a priori</em>. The problem is made even more challenging due to the high level of noise (both technical and biological) and the large number of dimensions (i.e. genes).</p>
</div>
<div id="dimensionality-reductions" class="section level3">
<h3><span class="header-section-number">4.1.2</span> Dimensionality reductions</h3>
<p>When working with large datasets, it can often be beneficial to apply some sort of dimensionality reduction method. By projecting the data onto a lower-dimensional sub-space, one is often able to significantly reduce the amount of noise. An additional benefit is that it is typically much easier to visualize the data in a 2 or 3-dimensional subspace. We have already discussed PCA (chapter <a href="construction-of-expression-matrix.html#visual-pca">3.10.2</a>) and t-SNE (chapter <a href="construction-of-expression-matrix.html#visual-pca">3.10.2</a>).</p>
</div>
<div id="clustering-methods" class="section level3">
<h3><span class="header-section-number">4.1.3</span> Clustering methods</h3>
<p><strong>Unsupervised clustering</strong> is useful in many different applications and it has been widely studied in machine learning. Some of the most popular approaches are <strong>hierarchical clustering</strong>, <strong>k-means clustering</strong> and <strong>graph-based clustering</strong>.</p>
<div id="hierarchical-clustering" class="section level4">
<h4><span class="header-section-number">4.1.3.1</span> Hierarchical clustering</h4>
<p>In <a href="https://en.wikipedia.org/wiki/Hierarchical_clustering">hierarchical clustering</a>, one can use either a bottom-up or a top-down approach. In the former case, each cell is initially assigned to its own cluster and pairs of clusters are subsequently merged to create a hieararchy:</p>
<div class="figure" style="text-align: center"><span id="fig:clust-hierarch-raw"></span>
<img src="figures/hierarchical_clustering1.png" alt="Raw data" width="30%" />
<p class="caption">
Figure 4.1: Raw data
</p>
</div>
<div class="figure" style="text-align: center"><span id="fig:clust-hierarch-dendr"></span>
<img src="figures/hierarchical_clustering2.png" alt="The hierarchical clustering dendrogram" width="50%" />
<p class="caption">
Figure 4.2: The hierarchical clustering dendrogram
</p>
</div>
<p>With a top-down strategy, one instead starts with all observations in one cluster and then recursively split each cluster to form a hierarchy. One of the advantages of this strategy is that the method is deterministic.</p>
</div>
<div id="k-means" class="section level4">
<h4><span class="header-section-number">4.1.3.2</span> k-means</h4>
<p>In <a href="https://en.wikipedia.org/wiki/K-means_clustering"><em>k</em>-means clustering</a>, the goal is to partition <em>N</em> cells into <em>k</em> different clusters. In an iterative manner, cluster centers are assigned and each cell is assigned to its nearest cluster:</p>
<div class="figure" style="text-align: center"><span id="fig:clust-k-means"></span>
<img src="figures/k-means.png" alt="Schematic representation of the k-means clustering" width="100%" />
<p class="caption">
Figure 4.3: Schematic representation of the k-means clustering
</p>
</div>
<p>Most methods for scRNA-seq analysis includes a <em>k</em>-means step at some point.</p>
</div>
<div id="graph-based-methods" class="section level4">
<h4><span class="header-section-number">4.1.3.3</span> Graph-based methods</h4>
<p>Over the last two decades there has been a lot of interest in analyzing networks in various domains. One goal is to identify groups or modules of nodes in a network.</p>
<div class="figure" style="text-align: center"><span id="fig:clust-graph"></span>
<img src="figures/graph_network.jpg" alt="Schematic representation of the graph network" width="100%" />
<p class="caption">
Figure 4.4: Schematic representation of the graph network
</p>
</div>
<p>Some of these methods can be applied to scRNA-seq data by building a graph where each node represents a cell. Note that constructing the graph and assigning weights to the edges is not trivial. One advantage of graph-based methods is that some of them are very efficient and can be applied to networks containing millions of nodes.</p>
</div>
</div>
<div id="challenges-in-clustering" class="section level3">
<h3><span class="header-section-number">4.1.4</span> Challenges in clustering</h3>
<ul>
<li>What is the number of clusters <em>k</em>?</li>
<li>What is a cell type?</li>
<li><strong>Scalability</strong>: in the last few years the number of cells in scRNA-seq experiments has grown by several orders of magnitude from ~<span class="math inline">\(10^2\)</span> to ~<span class="math inline">\(10^6\)</span></li>
<li>Tools are not user-friendly</li>
</ul>
</div>
<div id="tools-for-scrna-seq-data" class="section level3">
<h3><span class="header-section-number">4.1.5</span> Tools for scRNA-seq data</h3>
<div id="sincera" class="section level4">
<h4><span class="header-section-number">4.1.5.1</span> <a href="https://research.cchmc.org/pbge/sincera.html">SINCERA</a></h4>
<ul>
<li>SINCERA <span class="citation">(Guo et al. <a href="#ref-Guo2015-ok">2015</a>)</span> is based on hierarchical clustering</li>
<li>Data is converted to <em>z</em>-scores before clustering</li>
<li>Identify <em>k</em> by finding the first singleton cluster in the hierarchy</li>
</ul>
</div>
<div id="pcareduce" class="section level4">
<h4><span class="header-section-number">4.1.5.2</span> <a href="https://github.com/JustinaZ/pcaReduce">pcaReduce</a></h4>
<p>pcaReduce <span class="citation">(Žurauskienė and Yau <a href="#ref-Zurauskiene2016-kg">2016</a>)</span> combines PCA, <em>k</em>-means and “iterative” hierarchical clustering. Starting from a large number of clusters pcaReduce iteratively merges similar clusters; after each merging event it removes the principle component explaning the least variance in the data.</p>
</div>
<div id="sc3" class="section level4">
<h4><span class="header-section-number">4.1.5.3</span> <a href="http://bioconductor.org/packages/SC3/">SC3</a></h4>
<div class="figure" style="text-align: center"><span id="fig:clust-sc3"></span>
<img src="figures/sc3.png" alt="SC3 pipeline" width="100%" />
<p class="caption">
Figure 4.5: SC3 pipeline
</p>
</div>
<ul>
<li>SC3 <span class="citation">(Kiselev et al. <a href="#ref-Kiselev2016-bq">2016</a>)</span> is based on PCA and spectral dimensionality reductions</li>
<li>Utilises <em>k</em>-means</li>
<li>Additionally performs the consensus clustering</li>
</ul>
</div>
<div id="tsne-k-means" class="section level4">
<h4><span class="header-section-number">4.1.5.4</span> tSNE + k-means</h4>
<ul>
<li>Based on <strong>tSNE</strong> maps</li>
<li>Utilises <em>k</em>-means</li>
</ul>
</div>
<div id="snn-cliq" class="section level4">
<h4><span class="header-section-number">4.1.5.5</span> <a href="http://bioinfo.uncc.edu/SNNCliq/">SNN-Cliq</a></h4>
<p><code>SNN-Cliq</code> <span class="citation">(C. Xu and Su <a href="#ref-Xu2015-vf">2015</a>)</span> is a graph-based method. First the method identifies the k-nearest-neighbours of each cell according to the <em>distance</em> measure. This is used to calculate the number of Shared Nearest Neighbours (SNN) between each pair of cells. A graph is built by placing an edge between two cells If they have at least one SNN. Clusters are defined as groups of cells with many edges between them using a “clique” method. SNN-Cliq requires several parameters to be defined manually.</p>
</div>
<div id="seurat-clustering" class="section level4">
<h4><span class="header-section-number">4.1.5.6</span> Seurat clustering</h4>
<p><a href="https://github.com/satijalab/seurat"><code>Seurat</code></a> clustering is based on a <em>community detection</em> approach similar to <code>SNN-Cliq</code> and to one previously proposed for analyzing CyTOF data <span class="citation">(Levine et al. <a href="#ref-Levine2015-fk">2015</a>)</span>. Since <code>Seurat</code> has become more like an all-in-one tool for scRNA-seq data analysis we dedicate a separate chapter to discuss it in more details (chapter <a href="seurat-chapter.html#seurat-chapter">5</a>).</p>

</div>
</div>
</div>
<div id="clust-methods" class="section level2">
<h2><span class="header-section-number">4.2</span> Clustering example</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(pcaMethods)
<span class="kw">library</span>(pcaReduce)
<span class="kw">library</span>(SC3)
<span class="kw">library</span>(scater)
<span class="kw">library</span>(SingleCellExperiment)
<span class="kw">library</span>(pheatmap)
<span class="kw">library</span>(mclust)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)</code></pre></div>
<p>To illustrate clustering of scRNA-seq data, we consider the <code>Deng</code> dataset of cells from developing mouse embryo <span class="citation">(Deng et al. <a href="#ref-Deng2014-mx">2014</a>)</span>. We have preprocessed the dataset and created a <code>SingleCellExperiment</code> object in advance. We have also annotated the cells with the cell type information (it is the <code>cell_type1</code> and <code>cell_type2</code> columns in the <code>colData</code> slot).</p>
<div id="deng-dataset" class="section level3">
<h3><span class="header-section-number">4.2.1</span> Deng dataset</h3>
<p>Let’s load the data and look at it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;deng/deng-reads.rds&quot;</span>)
deng</code></pre></div>
<pre><code>## class: SingleCellExperiment 
## dim: 22431 268 
## metadata(0):
## assays(2): counts logcounts
## rownames(22431): Hvcn1 Gbp7 ... Sox5 Alg11
## rowData names(10): feature_symbol is_feature_control ...
##   total_counts log10_total_counts
## colnames(268): 16cell 16cell.1 ... zy.2 zy.3
## colData names(30): cell_type2 cell_type1 ... pct_counts_ERCC
##   is_cell_control
## reducedDimNames(0):
## spikeNames(1): ERCC</code></pre>
<p>Let’s look at the cell type annotation:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(<span class="kw">colData</span>(deng)<span class="op">$</span>cell_type2)</code></pre></div>
<pre><code>## 
##     16cell      4cell      8cell early2cell earlyblast  late2cell 
##         50         14         37          8         43         10 
##  lateblast   mid2cell   midblast         zy 
##         30         12         60          4</code></pre>
<p>A simple PCA analysis already separates some strong cell types and provides some insights in the data structure:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(deng, <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>)</code></pre></div>
<p><img src="18-clustering_files/figure-html/unnamed-chunk-5-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="sc3-1" class="section level3">
<h3><span class="header-section-number">4.2.2</span> SC3</h3>
<p>Let’s run <code>SC3</code> clustering on the Deng data. The advantage of the <code>SC3</code> is that it can directly ingest a <code>SingleCellExperiment</code> object.</p>
<p>Now let’s image we do not know the number of clusters <em>k</em> (cell types). <code>SC3</code> can estimate a number of clusters for you:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">sc3_estimate_k</span>(deng)</code></pre></div>
<pre><code>## Estimating k...</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">metadata</span>(deng)<span class="op">$</span>sc3<span class="op">$</span>k_estimation</code></pre></div>
<pre><code>## [1] 6</code></pre>
<p>Interestingly, the number of cell types predicted by <code>SC3</code> is smaller than in the original data annotation. However, early, mid and late stages of different cell types together, we will have exactly 6 cell types. We store the merged cell types in <code>cell_type1</code> column of the <code>colData</code> slot:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(deng, <span class="dt">colour_by =</span> <span class="st">&quot;cell_type1&quot;</span>)</code></pre></div>
<p><img src="18-clustering_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Now we are ready to run <code>SC3</code> (we also ask it to calculate biological properties of the clusters):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">sc3</span>(deng, <span class="dt">ks =</span> <span class="dv">10</span>, <span class="dt">biology =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## Setting SC3 parameters...</code></pre>
<pre><code>## Setting a range of k...</code></pre>
<pre><code>## Calculating distances between the cells...</code></pre>
<pre><code>## Performing transformations and calculating eigenvectors...</code></pre>
<pre><code>## Performing k-means clustering...</code></pre>
<pre><code>## Calculating consensus matrix...</code></pre>
<pre><code>## Calculating biology...</code></pre>
<p><code>SC3</code> result consists of several different outputs (please look in <span class="citation">(Kiselev et al. <a href="#ref-Kiselev2016-bq">2016</a>)</span> and <a href="http://bioconductor.org/packages/release/bioc/vignettes/SC3/inst/doc/my-vignette.html">SC3 vignette</a> for more details). Here we show some of them:</p>
<p>Consensus matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_plot_consensus</span>(deng, <span class="dt">k =</span> <span class="dv">10</span>, <span class="dt">show_pdata =</span> <span class="st">&quot;cell_type2&quot;</span>)</code></pre></div>
<p><img src="18-clustering_files/figure-html/unnamed-chunk-9-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">adjustedRandIndex</span>(<span class="kw">colData</span>(deng)<span class="op">$</span>cell_type2, <span class="kw">colData</span>(deng)<span class="op">$</span>sc3_10_clusters)</code></pre></div>
<pre><code>## [1] 0.7705208</code></pre>
<p>Silhouette plot:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_plot_silhouette</span>(deng, <span class="dt">k =</span> <span class="dv">10</span>)</code></pre></div>
<p><img src="18-clustering_files/figure-html/unnamed-chunk-10-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Heatmap of the expression matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_plot_expression</span>(deng, <span class="dt">k =</span> <span class="dv">10</span>, <span class="dt">show_pdata =</span> <span class="st">&quot;cell_type2&quot;</span>)</code></pre></div>
<p><img src="18-clustering_files/figure-html/unnamed-chunk-11-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Identified marker genes:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_plot_markers</span>(deng, <span class="dt">k =</span> <span class="dv">10</span>, <span class="dt">show_pdata =</span> <span class="st">&quot;cell_type2&quot;</span>)</code></pre></div>
<p><img src="18-clustering_files/figure-html/unnamed-chunk-12-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>PCA plot with highlighted <code>SC3</code> clusters:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(deng, <span class="dt">colour_by =</span> <span class="st">&quot;sc3_10_clusters&quot;</span>)</code></pre></div>
<p><img src="18-clustering_files/figure-html/unnamed-chunk-13-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Note, that one can also run <code>SC3</code> in an interactive <code>Shiny</code> session:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_interactive</span>(deng)</code></pre></div>
<p>This command will open <code>SC3</code> in a web browser.</p>
<ul>
<li><p><strong>Exercise 1</strong>: Run <code>SC3</code> for <span class="math inline">\(k\)</span> from 8 to 12 and explore different clustering solutions in your web browser.</p></li>
<li><p><strong>Exercise 2</strong>: Which clusters are the most stable when <span class="math inline">\(k\)</span> is changed from 8 to 12? (Look at the “Stability” tab)</p></li>
<li><p><strong>Exercise 3</strong>: Check out differentially expressed genes and marker genes for the obtained clusterings. Please use <span class="math inline">\(k=10\)</span>.</p></li>
<li><p><strong>Exercise 4</strong>: Change the marker genes threshold (the default is 0.85). Does <strong>SC3</strong> find more marker genes?</p></li>
</ul>
</div>
<div id="pcareduce-1" class="section level3">
<h3><span class="header-section-number">4.2.3</span> pcaReduce</h3>
<p><code>pcaReduce</code> operates directly on the expression matrix. It is recommended to use a gene filter and log transformation before running <code>pcaReduce</code>. We will use the default <code>SC3</code> gene filter (note that the <code>exprs</code> slot of a <code>scater</code> object is log-transformed by default).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># use the same gene filter as in SC3</span>
input &lt;-<span class="st"> </span><span class="kw">logcounts</span>(deng[<span class="kw">rowData</span>(deng)<span class="op">$</span>sc3_gene_filter, ])</code></pre></div>
<p>There are several parameters used by <code>pcaReduce</code>: * <code>nbt</code> defines a number of <code>pcaReduce</code> runs (it is stochastic and may have different solutions after different runs) * <code>q</code> defines number of dimensions to start clustering with. The output will contain partitions for all <span class="math inline">\(k\)</span> from 2 to q+1. * <code>method</code> defines a method used for clustering. <code>S</code> - to perform sampling based merging, <code>M</code> - to perform merging based on largest probability.</p>
<p>We will run <code>pcaReduce</code> 1 time:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># run pcaReduce 1 time creating hierarchies from 1 to 30 clusters</span>
pca.red &lt;-<span class="st"> </span><span class="kw">PCAreduce</span>(<span class="kw">t</span>(input), <span class="dt">nbt =</span> <span class="dv">1</span>, <span class="dt">q =</span> <span class="dv">30</span>, <span class="dt">method =</span> <span class="st">&#39;S&#39;</span>)[[<span class="dv">1</span>]]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colData</span>(deng)<span class="op">$</span>pcaReduce &lt;-<span class="st"> </span><span class="kw">as.character</span>(pca.red[,<span class="dv">32</span> <span class="op">-</span><span class="st"> </span><span class="dv">10</span>])
<span class="kw">plotPCA</span>(deng, <span class="dt">colour_by =</span> <span class="st">&quot;pcaReduce&quot;</span>)</code></pre></div>
<p><img src="18-clustering_files/figure-html/unnamed-chunk-17-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Exercise 5</strong>: Run pcaReduce for <span class="math inline">\(k=2\)</span> and plot a similar PCA plot. Does it look good?</p>
<p><strong>Hint</strong>: When running pcaReduce for different <span class="math inline">\(k\)</span>s you do not need to rerun PCAreduce function, just use already calculated <code>pca.red</code> object.</p>
<strong>Our solution</strong>:
<div class="figure" style="text-align: center"><span id="fig:clust-pca-reduce2"></span>
<img src="18-clustering_files/figure-html/clust-pca-reduce2-1.png" alt="Clustering solutions of pcaReduce method for $k=2$." width="672" />
<p class="caption">
Figure 4.6: Clustering solutions of pcaReduce method for <span class="math inline">\(k=2\)</span>.
</p>
</div>
<p><strong>Exercise 6</strong>: Compare the results between <code>SC3</code> and <code>pcaReduce</code> for <span class="math inline">\(k=10\)</span>. What is the main difference between the solutions provided by the two different methods?</p>
<p><strong>Our solution</strong>: <img src="18-clustering_files/figure-html/unnamed-chunk-18-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="tsne-kmeans" class="section level3">
<h3><span class="header-section-number">4.2.4</span> tSNE + kmeans</h3>
<p><a href="https://lvdmaaten.github.io/tsne/">tSNE</a> plots that we saw before (<a href="construction-of-expression-matrix.html#visual-tsne">3.10.3</a>) when used the <strong>scater</strong> package are made by using the <a href="https://cran.r-project.org/web/packages/Rtsne/index.html">Rtsne</a> and <a href="https://cran.r-project.org/web/packages/ggplot2/index.html">ggplot2</a> packages. Here we will do the same:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">plotTSNE</span>(deng, <span class="dt">rand_seed =</span> <span class="dv">1</span>, <span class="dt">return_SCE =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:clust-tsne"></span>
<img src="18-clustering_files/figure-html/clust-tsne-1.png" alt="tSNE map of the patient data" width="672" />
<p class="caption">
Figure 4.7: tSNE map of the patient data
</p>
</div>
<p>Note that all points on the plot above are black. This is different from what we saw before, when the cells were coloured based on the annotation. Here we do not have any annotation and all cells come from the same batch, therefore all dots are black.</p>
<p>Now we are going to apply <em>k</em>-means clustering algorithm to the cloud of points on the tSNE map. How many groups do you see in the cloud?</p>
<p>We will start with <span class="math inline">\(k=8\)</span>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colData</span>(deng)<span class="op">$</span>tSNE_kmeans &lt;-<span class="st"> </span><span class="kw">as.character</span>(<span class="kw">kmeans</span>(deng<span class="op">@</span>reducedDims<span class="op">$</span>TSNE, <span class="dt">centers =</span> <span class="dv">8</span>)<span class="op">$</span>clust)
<span class="kw">plotTSNE</span>(deng, <span class="dt">rand_seed =</span> <span class="dv">1</span>, <span class="dt">colour_by =</span> <span class="st">&quot;tSNE_kmeans&quot;</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:clust-tsne-kmeans2"></span>
<img src="18-clustering_files/figure-html/clust-tsne-kmeans2-1.png" alt="tSNE map of the patient data with 8 colored clusters, identified by the k-means clustering algorithm" width="672" />
<p class="caption">
Figure 4.8: tSNE map of the patient data with 8 colored clusters, identified by the k-means clustering algorithm
</p>
</div>
<p><strong>Exercise 7</strong>: Make the same plot for <span class="math inline">\(k=10\)</span>.</p>
<p><strong>Exercise 8</strong>: Compare the results between <code>SC3</code> and <code>tSNE+kmeans</code>. Can the results be improved by changing the <code>perplexity</code> parameter?</p>
<p><strong>Our solution</strong>: <img src="18-clustering_files/figure-html/unnamed-chunk-19-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>As you may have noticed, both <code>pcaReduce</code> and <code>tSNE+kmeans</code> are stochastic and give different results every time they are run. To get a better overview of the solutions, we need to run the methods multiple times. <code>SC3</code> is also stochastic, but thanks to the consensus step, it is more robust and less likely to produce different outcomes.</p>
</div>
<div id="snn-cliq-1" class="section level3">
<h3><span class="header-section-number">4.2.5</span> SNN-Cliq</h3>
<p>Here we run SNN-cliq with te default parameters provided in the author’s example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">distan &lt;-<span class="st"> &quot;euclidean&quot;</span>
par.k &lt;-<span class="st"> </span><span class="dv">3</span>
par.r &lt;-<span class="st"> </span><span class="fl">0.7</span>
par.m &lt;-<span class="st"> </span><span class="fl">0.5</span>
<span class="co"># construct a graph</span>
scRNA.seq.funcs<span class="op">::</span><span class="kw">SNN</span>(
    <span class="dt">data =</span> <span class="kw">t</span>(input),
    <span class="dt">outfile =</span> <span class="st">&quot;snn-cliq.txt&quot;</span>,
    <span class="dt">k =</span> par.k,
    <span class="dt">distance =</span> distan
)
<span class="co"># find clusters in the graph</span>
snn.res &lt;-<span class="st"> </span>
<span class="st">    </span><span class="kw">system</span>(
        <span class="kw">paste0</span>(
            <span class="st">&quot;python utils/Cliq.py &quot;</span>, 
            <span class="st">&quot;-i snn-cliq.txt &quot;</span>,
            <span class="st">&quot;-o res-snn-cliq.txt &quot;</span>,
            <span class="st">&quot;-r &quot;</span>, par.r,
            <span class="st">&quot; -m &quot;</span>, par.m
        ),
        <span class="dt">intern =</span> <span class="ot">TRUE</span>
    )
<span class="kw">cat</span>(<span class="kw">paste</span>(snn.res, <span class="dt">collapse =</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>))</code></pre></div>
<pre><code>## input file snn-cliq.txt
## find 66 quasi-cliques
## merged into 29 clusters
## unique assign done</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">snn.res &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;res-snn-cliq.txt&quot;</span>)
<span class="co"># remove files that were created during the analysis</span>
<span class="kw">system</span>(<span class="st">&quot;rm snn-cliq.txt res-snn-cliq.txt&quot;</span>)

<span class="kw">colData</span>(deng)<span class="op">$</span>SNNCliq &lt;-<span class="st"> </span><span class="kw">as.character</span>(snn.res[,<span class="dv">1</span>])
<span class="kw">plotPCA</span>(deng, <span class="dt">colour_by =</span> <span class="st">&quot;SNNCliq&quot;</span>)</code></pre></div>
<p><img src="18-clustering_files/figure-html/unnamed-chunk-20-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Exercise 9</strong>: Compare the results between <code>SC3</code> and <code>SNN-Cliq</code>.</p>
<p><strong>Our solution</strong>: <img src="18-clustering_files/figure-html/unnamed-chunk-21-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="sincera-1" class="section level3">
<h3><span class="header-section-number">4.2.6</span> SINCERA</h3>
<p>As mentioned in the previous chapter <a href="https://research.cchmc.org/pbge/sincera.html">SINCERA</a> is based on hierarchical clustering. One important thing to keep in mind is that it performs a gene-level z-score transformation before doing clustering:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># perform gene-by-gene per-sample z-score transformation</span>
dat &lt;-<span class="st"> </span><span class="kw">apply</span>(input, <span class="dv">1</span>, <span class="cf">function</span>(y) scRNA.seq.funcs<span class="op">::</span><span class="kw">z.transform.helper</span>(y))
<span class="co"># hierarchical clustering</span>
dd &lt;-<span class="st"> </span><span class="kw">as.dist</span>((<span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="kw">cor</span>(<span class="kw">t</span>(dat), <span class="dt">method =</span> <span class="st">&quot;pearson&quot;</span>))<span class="op">/</span><span class="dv">2</span>)
hc &lt;-<span class="st"> </span><span class="kw">hclust</span>(dd, <span class="dt">method =</span> <span class="st">&quot;average&quot;</span>)</code></pre></div>
<p>If the number of cluster is not known <a href="https://research.cchmc.org/pbge/sincera.html">SINCERA</a> can identify <strong>k</strong> as the minimum height of the hierarchical tree that generates no more than a specified number of singleton clusters (clusters containing only 1 cell)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">num.singleton &lt;-<span class="st"> </span><span class="dv">0</span>
kk &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">dim</span>(dat)[<span class="dv">2</span>]) {
    clusters &lt;-<span class="st"> </span><span class="kw">cutree</span>(hc, <span class="dt">k =</span> i)
    clustersizes &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">table</span>(clusters))
    singleton.clusters &lt;-<span class="st"> </span><span class="kw">which</span>(clustersizes<span class="op">$</span>Freq <span class="op">&lt;</span><span class="st"> </span><span class="dv">2</span>)
    <span class="cf">if</span> (<span class="kw">length</span>(singleton.clusters) <span class="op">&lt;=</span><span class="st"> </span>num.singleton) {
        kk &lt;-<span class="st"> </span>i
    } <span class="cf">else</span> {
        <span class="cf">break</span>;
    }
}
<span class="kw">cat</span>(kk)</code></pre></div>
<pre><code>## 6</code></pre>
<p>Let’s now visualize the SINCERA results as a heatmap:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">pheatmap</span>(
    <span class="kw">t</span>(dat),
    <span class="dt">cluster_cols =</span> hc,
    <span class="dt">cutree_cols =</span> kk,
    <span class="dt">kmeans_k =</span> <span class="dv">100</span>,
    <span class="dt">show_rownames =</span> <span class="ot">FALSE</span>
)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:clust-sincera"></span>
<img src="18-clustering_files/figure-html/clust-sincera-1.png" alt="Clustering solutions of SINCERA method using found $k$" width="672" />
<p class="caption">
Figure 4.9: Clustering solutions of SINCERA method using found <span class="math inline">\(k\)</span>
</p>
</div>
<p><strong>Exercise 10</strong>: Compare the results between <code>SC3</code> and <code>SNN-Cliq</code>.</p>
<p><strong>Our solution</strong>: <img src="18-clustering_files/figure-html/unnamed-chunk-24-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Exercise 11</strong>: Is using the singleton cluster criteria for finding <strong>k</strong> a good idea?</p>
</div>
<div id="sessioninfo-9" class="section level3">
<h3><span class="header-section-number">4.2.7</span> sessionInfo()</h3>
<pre><code>## R version 3.4.2 (2017-09-28)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS/LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats4    parallel  methods   stats     graphics  grDevices utils    
## [8] datasets  base     
## 
## other attached packages:
##  [1] pheatmap_1.0.8              scater_1.5.21              
##  [3] ggplot2_2.2.1               SC3_1.5.6                  
##  [5] SingleCellExperiment_0.99.4 SummarizedExperiment_1.6.5 
##  [7] DelayedArray_0.2.7          matrixStats_0.52.2         
##  [9] GenomicRanges_1.28.6        GenomeInfoDb_1.12.3        
## [11] IRanges_2.10.5              S4Vectors_0.14.7           
## [13] pcaReduce_1.0               mclust_5.3                 
## [15] mnormt_1.5-5                pcaMethods_1.68.0          
## [17] Biobase_2.36.2              BiocGenerics_0.22.1        
## [19] knitr_1.17                 
## 
## loaded via a namespace (and not attached):
##   [1] Rtsne_0.13              ggbeeswarm_0.6.0       
##   [3] colorspace_1.3-2        rjson_0.2.15           
##   [5] class_7.3-14            rprojroot_1.2          
##   [7] XVector_0.16.0          bit64_0.9-7            
##   [9] AnnotationDbi_1.38.2    mvtnorm_1.0-6          
##  [11] codetools_0.2-15        scRNA.seq.funcs_0.1.0  
##  [13] tximport_1.4.0          doParallel_1.0.11      
##  [15] robustbase_0.92-7       cluster_2.0.6          
##  [17] shinydashboard_0.6.1    shiny_1.0.5            
##  [19] rrcov_1.4-3             compiler_3.4.2         
##  [21] backports_1.1.1         assertthat_0.2.0       
##  [23] Matrix_1.2-7.1          lazyeval_0.2.0         
##  [25] limma_3.32.10           htmltools_0.3.6        
##  [27] tools_3.4.2             bindrcpp_0.2           
##  [29] gtable_0.2.0            glue_1.1.1             
##  [31] GenomeInfoDbData_0.99.0 reshape2_1.4.2         
##  [33] dplyr_0.7.4             doRNG_1.6.6            
##  [35] Rcpp_0.12.13            gdata_2.18.0           
##  [37] iterators_1.0.8         stringr_1.2.0          
##  [39] mime_0.5                rngtools_1.2.4         
##  [41] gtools_3.5.0            WriteXLS_4.0.0         
##  [43] hypergeo_1.2-13         statmod_1.4.30         
##  [45] XML_3.98-1.9            edgeR_3.18.1           
##  [47] DEoptimR_1.0-8          MASS_7.3-45            
##  [49] zlibbioc_1.22.0         scales_0.5.0           
##  [51] rhdf5_2.20.0            RColorBrewer_1.1-2     
##  [53] yaml_2.1.14             memoise_1.1.0          
##  [55] gridExtra_2.3           pkgmaker_0.22          
##  [57] biomaRt_2.32.1          stringi_1.1.5          
##  [59] RSQLite_2.0             highr_0.6              
##  [61] pcaPP_1.9-72            foreach_1.4.3          
##  [63] orthopolynom_1.0-5      e1071_1.6-8            
##  [65] contfrac_1.1-11         caTools_1.17.1         
##  [67] moments_0.14            rlang_0.1.2            
##  [69] pkgconfig_2.0.1         bitops_1.0-6           
##  [71] evaluate_0.10.1         lattice_0.20-34        
##  [73] ROCR_1.0-7              bindr_0.1              
##  [75] labeling_0.3            cowplot_0.8.0          
##  [77] bit_1.1-12              deSolve_1.20           
##  [79] plyr_1.8.4              magrittr_1.5           
##  [81] bookdown_0.5            R6_2.2.2               
##  [83] gplots_3.0.1            DBI_0.7                
##  [85] RCurl_1.95-4.8          tibble_1.3.4           
##  [87] KernSmooth_2.23-15      rmarkdown_1.6          
##  [89] viridis_0.4.0           locfit_1.5-9.1         
##  [91] grid_3.4.2              data.table_1.10.4-3    
##  [93] blob_1.1.0              digest_0.6.12          
##  [95] xtable_1.8-2            httpuv_1.3.5           
##  [97] elliptic_1.3-7          munsell_0.4.3          
##  [99] registry_0.3            beeswarm_0.2.3         
## [101] viridisLite_0.2.0       vipor_0.4.5</code></pre>

</div>
</div>
<div id="feature-selection" class="section level2">
<h2><span class="header-section-number">4.3</span> Feature Selection</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scRNA.seq.funcs)
<span class="kw">library</span>(matrixStats)
<span class="kw">library</span>(M3Drop)
<span class="kw">library</span>(RColorBrewer)
<span class="kw">library</span>(SingleCellExperiment)
<span class="kw">set.seed</span>(<span class="dv">1</span>)</code></pre></div>
<p>Single-cell RNASeq is capable of measuring the expression of many thousands of genes in every cell. However, in most situations only a portion of those will show a response to the biological condition of interest, e.g. differences in cell-type, drivers of differentiation, respond to an environmental stimulus. Most genes detected in a scRNASeq experiment will only be detected at different levels due to technical noise. One consequence of this is that technical noise and batch effects can obscure the biological signal of interest.</p>
<p>Thus, it is often advantageous to perform feature selection to remove those genes which only exhibit technical noise from downstream analysis. Not only does this generally increase the signal:noise ratio in the data; it also reduces the computational complexity of analyses, by reducing the total amount of data to be processed.</p>
<p>For scRNASeq data, we will be focusing on unsupervised methods of feature selection which don’t require any a priori information, such as cell-type labels or biological group, since they are not available, or may be unreliable, for many experiments. In contrast, differential expression (chapter <a href="biological-analysis.html#dechapter">4.6</a>) can be considered a form of supervised feature selection since it uses the known biological label of each sample to identify features (i.e. genes) which are expressed at different levels across groups.</p>
<p>For this section we will continue working with the Deng data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;deng/deng-reads.rds&quot;</span>)
cellLabels &lt;-<span class="st"> </span><span class="kw">colData</span>(deng)<span class="op">$</span>cell_type2</code></pre></div>
<p>This data can be QCed and normalized for library size using M3Drop, which removes cells with few detected genes, removes undetected genes, and converts raw counts to CPM.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng_list &lt;-<span class="st"> </span><span class="kw">M3DropCleanData</span>(
    <span class="kw">counts</span>(deng),
    <span class="dt">labels =</span> cellLabels,
    <span class="dt">min_detected_genes =</span> <span class="dv">100</span>,
    <span class="dt">is.counts =</span> <span class="ot">TRUE</span>
)
expr_matrix &lt;-<span class="st"> </span>deng_list<span class="op">$</span>data <span class="co"># Normalized &amp; filtered expression matrix</span>
celltype_labs &lt;-<span class="st"> </span><span class="kw">factor</span>(deng_list<span class="op">$</span>labels) <span class="co"># filtered cell-type labels</span>
cell_colors &lt;-<span class="st"> </span><span class="kw">brewer.pal</span>(<span class="kw">max</span>(<span class="dv">3</span>,<span class="kw">length</span>(<span class="kw">unique</span>(celltype_labs))), <span class="st">&quot;Set3&quot;</span>)</code></pre></div>
<p><strong>Exercise 1</strong>: How many cells &amp; genes have been removed by this filtering?</p>
<div id="identifying-genes-vs-a-null-model" class="section level3">
<h3><span class="header-section-number">4.3.1</span> Identifying Genes vs a Null Model</h3>
<p>There are two main approaches to unsupervised feature selection. The first is to identify genes which behave differently from a null model describing just the technical noise expected in the dataset.</p>
<p>If the dataset contains spike-in RNAs they can be used to directly model technical noise. However, measurements of spike-ins may not experience the same technical noise as endogenous transcripts <a href="https://www.nature.com/nmeth/journal/v14/n4/full/nmeth.4220.html">(Svensson et al., 2017)</a>. In addition, scRNASeq experiments often contain only a small number of spike-ins which reduces our confidence in fitted model parameters.</p>
<div id="highly-variable-genes" class="section level4">
<h4><span class="header-section-number">4.3.1.1</span> Highly Variable Genes</h4>
<p>The first method proposed to identify features in scRNASeq datasets was to identify highly variable genes (HVG). HVG assumes that if genes have large differences in expression across cells some of those differences are due to biological difference between the cells rather than technical noise. However, because of the nature of count data, there is a positive relationship between the mean expression of a gene and the variance in the read counts across cells. This relationship must be corrected for to properly identify HVGs.</p>
<p><strong>Exercise 2</strong> Using the functions rowMeans and rowVars to plot the relationship between mean expression and variance for all genes in this dataset. (Hint: use log=“xy” to plot on a log-scale).</p>
<p><img src="19-dropouts_files/figure-html/unnamed-chunk-5-1.png" width="816" style="display: block; margin: auto;" /> A popular method to correct for the relationship between variance and mean expression was proposed by <a href="http://www.nature.com/nmeth/journal/v10/n11/full/nmeth.2645.html">Brennecke et al.</a>. To use the Brennecke method, we first normalize for library size then calculate the mean and the square coefficient of variation (variation divided by the squared mean expression). A quadratic curve is fit to the relationship between these two variables for the ERCC spike-in, and then a chi-square test is used to find genes significantly above the curve. This method is included in the M3Drop package as the Brennecke_getVariableGenes(counts, spikes) function. However, this dataset does not contain spike-ins so we will use the entire dataset to estimate the technical noise.</p>
<p>In the figure below the red curve is the fitted technical noise model and the dashed line is the 95% CI. Pink dots are the genes with significant biological variability after multiple-testing correction.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Brennecke_HVG &lt;-<span class="st"> </span><span class="kw">BrenneckeGetVariableGenes</span>(
    expr_matrix,
    <span class="dt">fdr =</span> <span class="fl">0.01</span>,
    <span class="dt">minBiolDisp =</span> <span class="fl">0.5</span>
)</code></pre></div>
<p><img src="19-dropouts_files/figure-html/unnamed-chunk-6-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">HVG_genes &lt;-<span class="st"> </span>Brennecke_HVG<span class="op">$</span>Gene</code></pre></div>
</div>
<div id="high-dropout-genes" class="section level4">
<h4><span class="header-section-number">4.3.1.2</span> High Dropout Genes</h4>
<p>An alternative to finding HVGs is to identify genes with unexpectedly high numbers of zeros. The frequency of zeros, know as the “dropout rate”, is very closely related to expression level in scRNASeq data. Zeros are the dominant feature of single-cell RNASeq data, typically accounting for over half of the entries in the final expression matrix. These zeros predominantly result from the failure of mRNAs failing to be reversed transcribed <a href="http://www.biorxiv.org/content/early/2017/05/25/065094">(Andrews and Hemberg, 2016)</a>. Reverse transcription is an enzyme reaction thus can be modelled using the Michaelis-Menten equation:</p>
<p><span class="math display">\[P_{dropout} = 1 - S/(K + S)\]</span></p>
<p>where <span class="math inline">\(S\)</span> is the mRNA concentration in the cell (we will estimate this as average expression) and <span class="math inline">\(K\)</span> is the Michaelis-Menten constant.</p>
<p>Because the Michaelis-Menten equation is a convex non-linear function, genes which are differentially expression across two or more populations of cells in our dataset will be shifted up/right of the Michaelis-Menten model (see Figure below).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">K =<span class="st"> </span><span class="dv">49</span>
S_sim =<span class="st"> </span><span class="dv">10</span><span class="op">^</span><span class="kw">seq</span>(<span class="dt">from=</span><span class="op">-</span><span class="dv">3</span>, <span class="dt">to=</span><span class="dv">4</span>, <span class="dt">by=</span><span class="fl">0.05</span>) <span class="co"># range of expression values</span>
MM =<span class="st"> </span><span class="dv">1</span><span class="op">-</span>S_sim<span class="op">/</span>(K<span class="op">+</span>S_sim)
<span class="kw">plot</span>(S_sim, MM, <span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">lwd=</span><span class="dv">3</span>, <span class="dt">xlab=</span><span class="st">&quot;Expression&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;Dropout Rate&quot;</span>, <span class="dt">xlim=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1000</span>))
S1 =<span class="st"> </span><span class="dv">10</span>; P1 =<span class="st"> </span><span class="dv">1</span><span class="op">-</span>S1<span class="op">/</span>(K<span class="op">+</span>S1) <span class="co"># Expression &amp; dropouts for cells in condition 1</span>
S2 =<span class="st"> </span><span class="dv">750</span>; P2 =<span class="st"> </span><span class="dv">1</span><span class="op">-</span>S2<span class="op">/</span>(K<span class="op">+</span>S2) <span class="co"># Expression &amp; dropouts for cells in condition 2</span>
<span class="kw">points</span>(<span class="kw">c</span>(S1,S2),<span class="kw">c</span>(P1,P2), <span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span><span class="st">&quot;grey85&quot;</span>, <span class="dt">cex=</span><span class="dv">3</span>)
mix =<span class="st"> </span><span class="fl">0.5</span>; <span class="co"># proportion of cells in condition 1</span>
<span class="kw">points</span>(S1<span class="op">*</span>mix<span class="op">+</span>S2<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>mix), P1<span class="op">*</span>mix<span class="op">+</span>P2<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>mix), <span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span><span class="st">&quot;grey35&quot;</span>, <span class="dt">cex=</span><span class="dv">3</span>)</code></pre></div>
<p><img src="19-dropouts_files/figure-html/unnamed-chunk-7-1.png" width="816" style="display: block; margin: auto;" /> <strong>Note</strong>: add <code>log=&quot;x&quot;</code> to the <code>plot</code> call above to see how this looks on the log scale, which is used in M3Drop figures.</p>
<p><strong>Exercise 3</strong>: Produce the same plot as above with different expression levels (S1 &amp; S2) and/or mixtures (mix).</p>
<p>We use M3Drop to identify significant outliers to the right of the MM curve. We also apply 1% FDR multiple testing correction:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M3Drop_genes &lt;-<span class="st"> </span><span class="kw">M3DropFeatureSelection</span>(
    expr_matrix,
    <span class="dt">mt_method =</span> <span class="st">&quot;fdr&quot;</span>,
    <span class="dt">mt_threshold =</span> <span class="fl">0.01</span>
)</code></pre></div>
<p><img src="19-dropouts_files/figure-html/unnamed-chunk-8-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M3Drop_genes &lt;-<span class="st"> </span>M3Drop_genes<span class="op">$</span>Gene</code></pre></div>
<p>An alternative method is contained in the M3Drop package that is tailored specifically for UMI-tagged data which generally contains many zeros resulting from low sequencing coverage in addition to those resulting from insufficient reverse-transcription. This model is the Depth-Adjusted Negative Binomial (DANB). This method describes each expression observation as a negative binomial model with a mean related to both the mean expression of the respective gene and the sequencing depth of the respective cell, and a variance related to the mean-expression of the gene.</p>
<p>Unlike the Michaelis-Menten and HVG methods there isn’t a reliable statistical test for features selected by this model, so we will consider the top 1500 genes instead.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng_int &lt;-<span class="st"> </span><span class="kw">NBumiConvertToInteger</span>(<span class="kw">counts</span>(deng))
DANB_fit &lt;-<span class="st"> </span><span class="kw">NBumiFitModel</span>(deng_int) <span class="co"># DANB is fit to the raw count matrix</span>
<span class="co"># Perform DANB feature selection</span>
DropFS &lt;-<span class="st"> </span><span class="kw">NBumiFeatureSelectionCombinedDrop</span>(DANB_fit)
DANB_genes &lt;-<span class="st"> </span><span class="kw">names</span>(DropFS[<span class="dv">1</span><span class="op">:</span><span class="dv">1500</span>])</code></pre></div>
</div>
</div>
<div id="correlated-expression" class="section level3">
<h3><span class="header-section-number">4.3.2</span> Correlated Expression</h3>
<p>A completely different approach to feature selection is to use gene-gene correlations. This method is based on the idea that multiple genes will be differentially expressed between different cell-types or cell-states. Genes which are expressed in the same cell-population will be positively correlated with each other where as genes expressed in different cell-populations will be negatively correated with each other. Thus important genes can be identified by the magnitude of their correlation with other genes.</p>
<p>The limitation of this method is that it assumes technical noise is random and independent for each cell, thus shouldn’t produce gene-gene correlations, but this assumption is violated by batch effects which are generally systematic between different experimental batches and will produce gene-gene correlations. As a result it is more appropriate to take the top few thousand genes as ranked by gene-gene correlation than consider the significance of the correlations.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cor_mat &lt;-<span class="st"> </span><span class="kw">cor</span>(<span class="kw">t</span>(expr_matrix), <span class="dt">method=</span><span class="st">&quot;spearman&quot;</span>) <span class="co">#Gene-gene correlations</span>
<span class="kw">diag</span>(cor_mat) &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="dt">times=</span><span class="kw">nrow</span>(expr_matrix))
score &lt;-<span class="st"> </span><span class="kw">apply</span>(cor_mat, <span class="dv">1</span>, <span class="cf">function</span>(x) {<span class="kw">max</span>(<span class="kw">abs</span>(x))}) <span class="co">#Correlation of highest magnitude</span>
<span class="kw">names</span>(score) &lt;-<span class="st"> </span><span class="kw">rownames</span>(expr_matrix);
score &lt;-<span class="st"> </span>score[<span class="kw">order</span>(<span class="op">-</span>score)]
Cor_genes =<span class="st"> </span><span class="kw">names</span>(score[<span class="dv">1</span><span class="op">:</span><span class="dv">1500</span>])</code></pre></div>
<p>Lastly, another common method for feature selection in scRNASeq data is to use PCA loadings. Genes with high PCA loadings are likely to be highly variable and correlated with many other variable genes, thus may be relevant to the underlying biology. However, as with gene-gene correlations PCA loadings tend to be susceptible to detecting systematic variation due to batch effects; thus it is recommended to plot the PCA results to determine those components corresponding to the biological variation rather than batch effects.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pca &lt;-<span class="st"> </span><span class="kw">prcomp</span>(<span class="kw">log</span>(expr_matrix<span class="op">+</span><span class="dv">1</span>)<span class="op">/</span><span class="kw">log</span>(<span class="dv">2</span>)); <span class="co"># PCA is typically performed on log-transformed expression data</span>

<span class="kw">plot</span>(pca<span class="op">$</span>rotation[,<span class="dv">1</span>], pca<span class="op">$</span>rotation[,<span class="dv">2</span>], <span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span>cell_colors[<span class="kw">as.factor</span>(celltype_labs)]) <span class="co"># plot projection</span></code></pre></div>
<p><img src="19-dropouts_files/figure-html/unnamed-chunk-11-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">score &lt;-<span class="st"> </span><span class="kw">rowSums</span>(<span class="kw">abs</span>(pca<span class="op">$</span>x[,<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>)])) <span class="co"># calculate loadings for components 1 and 2</span>
<span class="kw">names</span>(score) &lt;-<span class="st"> </span><span class="kw">rownames</span>(expr_matrix)
score &lt;-<span class="st"> </span>score[<span class="kw">order</span>(<span class="op">-</span>score)]
PCA_genes =<span class="st"> </span><span class="kw">names</span>(score[<span class="dv">1</span><span class="op">:</span><span class="dv">1500</span>])</code></pre></div>
<p><strong>Exercise 4</strong> Consider the top 5 principal components. Which appear to be most biologically relevant? How does the top 1,500 features change if you consider the loadings for those components?</p>
</div>
<div id="comparing-methods" class="section level3">
<h3><span class="header-section-number">4.3.3</span> Comparing Methods</h3>
<p>We can check whether the identified features really do represent genes differentially expressed between cell-types in this dataset.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">M3DropExpressionHeatmap</span>(
    M3Drop_genes,
    expr_matrix,
    <span class="dt">cell_labels =</span> celltype_labs
)</code></pre></div>
<p><img src="19-dropouts_files/figure-html/unnamed-chunk-12-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>We can also consider how consistent each feature selection method is with the others using the Jaccard Index:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">J &lt;-<span class="st"> </span><span class="kw">sum</span>(M3Drop_genes <span class="op">%in%</span><span class="st"> </span>HVG_genes)<span class="op">/</span><span class="kw">length</span>(<span class="kw">unique</span>(<span class="kw">c</span>(M3Drop_genes, HVG_genes)))</code></pre></div>
<p><strong>Exercise 5</strong> Plot the expression of the features for each of the other methods. Which appear to be differentially expressed? How consistent are the different methods for this dataset?</p>
</div>
<div id="sessioninfo-10" class="section level3">
<h3><span class="header-section-number">4.3.4</span> sessionInfo()</h3>
<pre><code>## R version 3.4.2 (2017-09-28)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS/LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] parallel  stats4    methods   stats     graphics  grDevices utils    
## [8] datasets  base     
## 
## other attached packages:
##  [1] SingleCellExperiment_0.99.4 SummarizedExperiment_1.6.5 
##  [3] DelayedArray_0.2.7          Biobase_2.36.2             
##  [5] GenomicRanges_1.28.6        GenomeInfoDb_1.12.3        
##  [7] IRanges_2.10.5              S4Vectors_0.14.7           
##  [9] BiocGenerics_0.22.1         RColorBrewer_1.1-2         
## [11] M3Drop_2.02.00              numDeriv_2016.8-1          
## [13] matrixStats_0.52.2          scRNA.seq.funcs_0.1.0      
## [15] knitr_1.17                 
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.13            XVector_0.16.0         
##  [3] compiler_3.4.2          zlibbioc_1.22.0        
##  [5] moments_0.14            bitops_1.0-6           
##  [7] tools_3.4.2             digest_0.6.12          
##  [9] statmod_1.4.30          evaluate_0.10.1        
## [11] Rtsne_0.13              lattice_0.20-34        
## [13] Matrix_1.2-7.1          yaml_2.1.14            
## [15] GenomeInfoDbData_0.99.0 stringr_1.2.0          
## [17] contfrac_1.1-11         gtools_3.5.0           
## [19] elliptic_1.3-7          caTools_1.17.1         
## [21] rprojroot_1.2           grid_3.4.2             
## [23] deSolve_1.20            orthopolynom_1.0-5     
## [25] rmarkdown_1.6           bookdown_0.5           
## [27] gdata_2.18.0            magrittr_1.5           
## [29] backports_1.1.1         gplots_3.0.1           
## [31] htmltools_0.3.6         MASS_7.3-45            
## [33] bbmle_1.0.19            KernSmooth_2.23-15     
## [35] stringi_1.1.5           RCurl_1.95-4.8         
## [37] hypergeo_1.2-13</code></pre>

</div>
</div>
<div id="pseudotime-analysis" class="section level2">
<h2><span class="header-section-number">4.4</span> Pseudotime analysis</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(SingleCellExperiment)
<span class="kw">library</span>(TSCAN)
<span class="kw">library</span>(M3Drop)
<span class="kw">library</span>(monocle)
<span class="kw">library</span>(destiny)
<span class="kw">library</span>(SLICER)
<span class="kw">set.seed</span>(<span class="dv">1</span>)</code></pre></div>
<p>In many situations, one is studying a process where cells change continuously. This includes, for example, many differentiation processes taking place during development: following a stimulus, cells will change from one cell-type to another. Ideally, we would like to monitor the expression levels of an individual cell over time. Unfortunately, such monitoring is not possible with scRNA-seq since the cell is lysed (destroyed) when the RNA is extracted.</p>
<p>Instead, we must sample at multiple time-points and obtain snapshots of the gene expression profiles. Since some of the cells will proceed faster along the differentiation than others, each snapshot may contain cells at varying points along the developmental progression. We use statistical methods to order the cells along one or more trajectories which represent the underlying developmental trajectories, this ordering is referred to as “pseudotime”.</p>
<p>In this chapter we will consider four different tools: Monocle, TSCAN, destiny and SLICER for ordering cells according to their pseudotime development. To illustrate the methods we will be using a dataset on mouse embryonic development <span class="citation">(Deng et al. <a href="#ref-Deng2014-mx">2014</a>)</span>. The dataset consists of 268 cells from 10 different time-points of early mouse development. In this case, there is no need for pseudotime alignment since the cell labels provide information about the development trajectory. Thus, the labels allow us to establish a ground truth so that we can evaluate and compare the different methods.</p>
<p>A recent review by Cannoodt et al provides a detailed summary of the various computational methods for trajectory inference from single-cell transcriptomics <span class="citation">(Cannoodt, Saelens, and Saeys <a href="#ref-Cannoodt2016-uj">2016</a>)</span>. They discuss several tools, but unfortunately for our purposes many of these tools do not have complete or well-maintained implementations, and/or are not implemented in R.</p>
<p>Cannoodt et al cover:</p>
<ul>
<li>SCUBA - Matlab implementation</li>
<li>Wanderlust - Matlab (and requires registration to even download)</li>
<li>Wishbone - Python</li>
<li>SLICER - R, but package only available on Github</li>
<li>SCOUP - C++ command line tool</li>
<li>Waterfall - R, but one R script in supplement</li>
<li>Mpath - R pkg, but available as tar.gz on Github; function documentation but no vignette/workflow</li>
<li>Monocle - Bioconductor package</li>
<li>TSCAN - Bioconductor package</li>
</ul>
<p>Unfortunately only two tools discussed (Monocle and TSCAN) meet the gold standard of open-source software hosted in a reputable repository.</p>
<p>The following figures from the paper summarise some of the features of the various tools.</p>
<div class="figure" style="text-align: center"><span id="fig:pseudotime-methods-description"></span>
<img src="figures/cannoodt_pseudotime_properties.png" alt="Descriptions of trajectory inference methods for single-cell transcriptomics data (Fig. 2 from Cannoodt et al, 2016)." width="90%" />
<p class="caption">
Figure 4.10: Descriptions of trajectory inference methods for single-cell transcriptomics data (Fig. 2 from Cannoodt et al, 2016).
</p>
</div>
<div class="figure" style="text-align: center"><span id="fig:pseudotime-methods"></span>
<img src="figures/cannoodt_pseudotime_methods.png" alt="Characterization of trajectory inference methods for single-cell transcriptomics data (Fig. 3 from Cannoodt et al, 2016)." width="90%" />
<p class="caption">
Figure 4.11: Characterization of trajectory inference methods for single-cell transcriptomics data (Fig. 3 from Cannoodt et al, 2016).
</p>
</div>
<div id="tscan" class="section level3">
<h3><span class="header-section-number">4.4.1</span> TSCAN</h3>
<p>TSCAN combines clustering with pseudotime analysis. First it clusters the cells using <code>mclust</code>, which is based on a mixture of normal distributions. Then it builds a minimum spanning tree to connect the clusters. The branch of this tree that connects the largest number of clusters is the main branch which is used to determine pseudotime.</p>
<p>First we will try to use all genes to order the cells.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng_counts &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;deng/deng-reads.rds&quot;</span>)
cellLabels &lt;-<span class="st"> </span><span class="kw">colData</span>(deng_counts)<span class="op">$</span>cell_type2
deng &lt;-<span class="st"> </span><span class="kw">logcounts</span>(deng_counts)
<span class="kw">colnames</span>(deng) &lt;-<span class="st"> </span>cellLabels
procdeng &lt;-<span class="st"> </span>TSCAN<span class="op">::</span><span class="kw">preprocess</span>(deng)
<span class="kw">colnames</span>(procdeng) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(deng)
dengclust &lt;-<span class="st"> </span>TSCAN<span class="op">::</span><span class="kw">exprmclust</span>(procdeng, <span class="dt">clusternum =</span> <span class="dv">10</span>)
TSCAN<span class="op">::</span><span class="kw">plotmclust</span>(dengclust)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/tscan-all-genes-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dengorderTSCAN &lt;-<span class="st"> </span>TSCAN<span class="op">::</span><span class="kw">TSCANorder</span>(dengclust, <span class="dt">orderonly =</span> F)
pseudotime_order_tscan &lt;-<span class="st"> </span><span class="kw">as.character</span>(dengorderTSCAN<span class="op">$</span>sample_name)</code></pre></div>
<p>We can also examine which timepoints have been assigned to each state:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cellLabels[dengclust<span class="op">$</span>clusterid <span class="op">==</span><span class="st"> </span><span class="dv">10</span>]</code></pre></div>
<pre><code>##  [1] late2cell mid2cell  mid2cell  mid2cell  mid2cell  mid2cell  mid2cell 
##  [8] mid2cell  mid2cell  mid2cell  mid2cell  mid2cell  mid2cell 
## 10 Levels: 16cell 4cell 8cell early2cell earlyblast ... zy</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">colours &lt;-<span class="st"> </span><span class="kw">rainbow</span>(<span class="dt">n =</span> <span class="dv">10</span>) <span class="co"># red = early, violet = late</span>
tmp &lt;-
<span class="st">    </span><span class="kw">factor</span>(
        cellLabels[<span class="kw">as.numeric</span>(pseudotime_order_tscan)],
        <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;early2cell&quot;</span>, <span class="st">&quot;mid2cell&quot;</span>, <span class="st">&quot;late2cell&quot;</span>, <span class="st">&quot;4cell&quot;</span>, <span class="st">&quot;8cell&quot;</span>,
                   <span class="st">&quot;16cell&quot;</span>, <span class="st">&quot;earlyblast&quot;</span>, <span class="st">&quot;midblast&quot;</span>, <span class="st">&quot;lateblast&quot;</span>)
    )
<span class="kw">plot</span>(
    <span class="kw">as.numeric</span>(tmp),
    <span class="dt">xlab =</span> <span class="st">&quot;Pseudotime Order&quot;</span>,
    <span class="dt">ylab =</span> <span class="st">&quot;Timepoint&quot;</span>,
    <span class="dt">col =</span> colours[tmp],
    <span class="dt">pch =</span> <span class="dv">16</span>
)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/tscan-vs-truth-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Exercise 1</strong> Compare results for different numbers of clusters (<code>clusternum</code>).</p>
</div>
<div id="monocle" class="section level3">
<h3><span class="header-section-number">4.4.2</span> monocle</h3>
<p>Monocle skips the clustering stage of TSCAN and directly builds a minimum spanning tree on a reduced dimension representation of the cells to connect all cells. Monocle then identifies the longest path in this tree to determine pseudotime. If the data contains diverging trajectories (i.e. one cell type differentiates into two different cell-types), monocle can identify these. Each of the resulting forked paths is defined as a separate cell state.</p>
<p>Unfortunately, Monocle does not work when all the genes are used, so we must carry out feature selection. First, we use M3Drop:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m3dGenes &lt;-<span class="st"> </span><span class="kw">as.character</span>(
    <span class="kw">M3DropFeatureSelection</span>(<span class="kw">counts</span>(deng_counts))<span class="op">$</span>Gene
)</code></pre></div>
<pre><code>## Warning in bg__calc_variables(expr_mat): Warning: Removing 1134 invariant
## genes.</code></pre>
<p><img src="20-pseudotime_files/figure-html/m3d-select-genes-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d &lt;-<span class="st"> </span>deng[<span class="kw">which</span>(<span class="kw">rownames</span>(deng) <span class="op">%in%</span><span class="st"> </span>m3dGenes), ]
d &lt;-<span class="st"> </span>d[<span class="op">!</span><span class="kw">duplicated</span>(<span class="kw">rownames</span>(d)), ]</code></pre></div>
<p>Now run monocle:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colnames</span>(d) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(d)
geneNames &lt;-<span class="st"> </span><span class="kw">rownames</span>(d)
<span class="kw">rownames</span>(d) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(d)
pd &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">timepoint =</span> cellLabels)
pd &lt;-<span class="st"> </span><span class="kw">new</span>(<span class="st">&quot;AnnotatedDataFrame&quot;</span>, <span class="dt">data=</span>pd)
fd &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">gene_short_name =</span> geneNames)
fd &lt;-<span class="st"> </span><span class="kw">new</span>(<span class="st">&quot;AnnotatedDataFrame&quot;</span>, <span class="dt">data=</span>fd)

dCellData &lt;-<span class="st"> </span><span class="kw">newCellDataSet</span>(d, <span class="dt">phenoData =</span> pd, <span class="dt">featureData =</span> fd, <span class="dt">expressionFamily =</span> <span class="kw">tobit</span>())
dCellData &lt;-<span class="st"> </span><span class="kw">setOrderingFilter</span>(dCellData, <span class="kw">which</span>(geneNames <span class="op">%in%</span><span class="st"> </span>m3dGenes))
dCellData &lt;-<span class="st"> </span><span class="kw">estimateSizeFactors</span>(dCellData)
dCellDataSet &lt;-<span class="st"> </span><span class="kw">reduceDimension</span>(dCellData, <span class="dt">pseudo_expr =</span> <span class="dv">1</span>)
dCellDataSet &lt;-<span class="st"> </span><span class="kw">orderCells</span>(dCellDataSet, <span class="dt">reverse =</span> <span class="ot">FALSE</span>)
<span class="kw">plot_cell_trajectory</span>(dCellDataSet)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/monocle-all-genes-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Store the ordering</span>
pseudotime_monocle &lt;-
<span class="st">    </span><span class="kw">data.frame</span>(
        <span class="dt">Timepoint =</span> <span class="kw">phenoData</span>(dCellDataSet)<span class="op">$</span>timepoint,
        <span class="dt">pseudotime =</span> <span class="kw">phenoData</span>(dCellDataSet)<span class="op">$</span>Pseudotime,
        <span class="dt">State=</span><span class="kw">phenoData</span>(dCellDataSet)<span class="op">$</span>State
    )
<span class="kw">rownames</span>(pseudotime_monocle) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(d)
pseudotime_order_monocle &lt;-
<span class="st">    </span><span class="kw">rownames</span>(pseudotime_monocle[<span class="kw">order</span>(pseudotime_monocle<span class="op">$</span>pseudotime), ])</code></pre></div>
<p>We can again compare the inferred pseudotime to the known sampling timepoints.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">monocle_time_point &lt;-<span class="st"> </span><span class="kw">factor</span>(
     pseudotime_monocle<span class="op">$</span>Timepoint,
     <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;early2cell&quot;</span>, <span class="st">&quot;mid2cell&quot;</span>, <span class="st">&quot;late2cell&quot;</span>, <span class="st">&quot;4cell&quot;</span>, <span class="st">&quot;8cell&quot;</span>,
                   <span class="st">&quot;16cell&quot;</span>, <span class="st">&quot;earlyblast&quot;</span>, <span class="st">&quot;midblast&quot;</span>, <span class="st">&quot;lateblast&quot;</span>)
)

<span class="kw">plot</span>(
    pseudotime_monocle<span class="op">$</span>pseudotime,
    monocle_time_point,
    <span class="dt">xlab =</span> <span class="st">&quot;Pseudotime&quot;</span>,
    <span class="dt">ylab =</span> <span class="st">&quot;Timepoint&quot;</span>,
    <span class="dt">col =</span> colours[monocle_time_point],
    <span class="dt">pch =</span> <span class="dv">16</span>
)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/monocle-vs-truth-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="diffusion-maps" class="section level3">
<h3><span class="header-section-number">4.4.3</span> Diffusion maps</h3>
<p><a href="https://en.wikipedia.org/wiki/Diffusion_map">Diffusion maps</a> were introduced by <a href="http://www.sciencedirect.com/science/article/pii/S1063520306000546">Ronald Coifman and Stephane Lafon</a>, and the underlying idea is to assume that the data are samples from a diffusion process. The method infers the low-dimensional manifold by estimating the eigenvalues and eigenvectors for the diffusion operator related to the data.</p>
<p><a href="http://biorxiv.org/content/biorxiv/early/2015/08/04/023309.full.pdf">Haghverdi et al</a> have applied the diffusion maps concept to the analysis of single-cell RNA-seq data to create an R package called <a href="http://bioconductor.org/packages/destiny">destiny</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dm &lt;-<span class="st"> </span><span class="kw">DiffusionMap</span>(<span class="kw">t</span>(<span class="kw">log2</span>(deng <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)))
tmp &lt;-<span class="st"> </span><span class="kw">factor</span>(
    <span class="kw">colnames</span>(deng),
    <span class="dt">levels =</span> <span class="kw">c</span>(
        <span class="st">&quot;early2cell&quot;</span>,
        <span class="st">&quot;mid2cell&quot;</span>,
        <span class="st">&quot;late2cell&quot;</span>,
        <span class="st">&quot;4cell&quot;</span>,
        <span class="st">&quot;8cell&quot;</span>,
        <span class="st">&quot;16cell&quot;</span>,
        <span class="st">&quot;earlyblast&quot;</span>,
        <span class="st">&quot;midblast&quot;</span>,
        <span class="st">&quot;lateblast&quot;</span>
    )
)
<span class="kw">plot</span>(
    <span class="kw">eigenvectors</span>(dm)[,<span class="dv">1</span>],
    <span class="kw">eigenvectors</span>(dm)[,<span class="dv">2</span>],
    <span class="dt">xlab =</span> <span class="st">&quot;Diffusion component 1&quot;</span>,
    <span class="dt">ylab =</span> <span class="st">&quot;Diffusion component 2&quot;</span>,
    <span class="dt">col =</span> colours[tmp],
    <span class="dt">pch =</span> <span class="dv">16</span>
)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/destiny-deng-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Like the other methods, destiny does a good job at ordering the early time-points, but it is unable to distinguish the later ones.</p>
<p><strong>Exercise 2</strong> Do you get a better resolution between the later time points by considering additional eigenvectors?</p>
<p><strong>Exercise 3</strong> How does the ordering change if you only use the genes identified by M3Drop?</p>
</div>
<div id="slicer" class="section level3">
<h3><span class="header-section-number">4.4.4</span> SLICER</h3>
<p>The SLICER method is an algorithm for constructing trajectories that describe gene expression changes during a sequential biological process, just as Monocle and TSCAN are. SLICER is designed to capture highly nonlinear gene expression changes, automatically select genes related to the process, and detect multiple branch and loop features in the trajectory <span class="citation">(Welch, Hartemink, and Prins <a href="#ref-Welch2016-jr">2016</a>)</span>. The SLICER R package is available from its <a href="https://github.com/jw156605/SLICER">GitHub repository</a> and can be installed from there using the <code>devtools</code> package.</p>
<p>We use the <code>select_genes</code> function in SLICER to automatically select the genes to use in builing the cell trajectory. The function uses “neighbourhood variance” to identify genes that vary smoothly, rather than fluctuating randomly, across the set of cells. Following this, we determine which value of “k” (number of nearest neighbours) yields an embedding that most resembles a trajectory. Then we estimate the <a href="https://en.wikipedia.org/wiki/Nonlinear_dimensionality_reduction">locally linear embedding</a> of the cells.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">require</span>(<span class="st">&quot;lle&quot;</span>)
slicer_genes &lt;-<span class="st"> </span><span class="kw">select_genes</span>(<span class="kw">t</span>(deng))
k &lt;-<span class="st"> </span><span class="kw">select_k</span>(<span class="kw">t</span>(deng[slicer_genes,]), <span class="dt">kmin =</span> <span class="dv">30</span>, <span class="dt">kmax=</span><span class="dv">60</span>)</code></pre></div>
<pre><code>## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates
## finding neighbours
## calculating weights
## computing coordinates</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">slicer_traj_lle &lt;-<span class="st"> </span><span class="kw">lle</span>(<span class="kw">t</span>(deng[slicer_genes,]), <span class="dt">m =</span> <span class="dv">2</span>, k)<span class="op">$</span>Y</code></pre></div>
<pre><code>## finding neighbours
## calculating weights
## computing coordinates</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(slicer_traj_lle, <span class="dt">xlab =</span> <span class="st">&quot;LLE Comp 1&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;LLE Comp 2&quot;</span>,
     <span class="dt">main =</span> <span class="st">&quot;Locally linear embedding of cells from SLICER&quot;</span>, 
     <span class="dt">col=</span>colours[tmp], <span class="dt">pch=</span><span class="dv">16</span>)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/slicer-analyis-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>With the locally linear embedding computed we can construct a k-nearest neighbour graph that is fully connected. This plot displays a (yellow) circle for each cell, with the cell ID number overlaid in blue. Here we show the graph computed using 10 nearest neighbours. Here, SLICER appears to detect one major trajectory with one branch.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">slicer_traj_graph &lt;-<span class="st"> </span><span class="kw">conn_knn_graph</span>(slicer_traj_lle, <span class="dv">10</span>)
<span class="kw">plot</span>(slicer_traj_graph, <span class="dt">main =</span> <span class="st">&quot;Fully connected kNN graph from SLICER&quot;</span>)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/slicer-build-graph-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>From this graph we can identify “extreme” cells that are candidates for start/end cells in the trajectory.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ends &lt;-<span class="st"> </span><span class="kw">find_extreme_cells</span>(slicer_traj_graph, slicer_traj_lle)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/slicer-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">start &lt;-<span class="st"> </span>ends[<span class="dv">1</span>]</code></pre></div>
<p>Having defined a start cell we can order the cells in the estimated pseudotime.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pseudotime_order_slicer &lt;-<span class="st"> </span><span class="kw">cell_order</span>(slicer_traj_graph, start)
branches &lt;-<span class="st"> </span><span class="kw">assign_branches</span>(slicer_traj_graph, start)

pseudotime_slicer &lt;-
<span class="st">    </span><span class="kw">data.frame</span>(
        <span class="dt">Timepoint =</span> cellLabels,
        <span class="dt">pseudotime =</span> <span class="ot">NA</span>,
        <span class="dt">State =</span> branches
    )
pseudotime_slicer<span class="op">$</span>pseudotime[pseudotime_order_slicer] &lt;-
<span class="st">    </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(pseudotime_order_slicer)</code></pre></div>
<p>We can again compare the inferred pseudotime to the known sampling timepoints. SLICER does not provide a pseudotime value per se, just an ordering of cells.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">slicer_time_point &lt;-<span class="st"> </span><span class="kw">factor</span>(
     pseudotime_slicer<span class="op">$</span>Timepoint,
     <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;early2cell&quot;</span>, <span class="st">&quot;mid2cell&quot;</span>, <span class="st">&quot;late2cell&quot;</span>, <span class="st">&quot;4cell&quot;</span>, <span class="st">&quot;8cell&quot;</span>,
                   <span class="st">&quot;16cell&quot;</span>, <span class="st">&quot;earlyblast&quot;</span>, <span class="st">&quot;midblast&quot;</span>, <span class="st">&quot;lateblast&quot;</span>)
)

<span class="kw">plot</span>(
    pseudotime_slicer<span class="op">$</span>pseudotime,
    slicer_time_point,
    <span class="dt">xlab =</span> <span class="st">&quot;Pseudotime&quot;</span>,
    <span class="dt">ylab =</span> <span class="st">&quot;Timepoint&quot;</span>,
    <span class="dt">col =</span> colours[slicer_time_point],
    <span class="dt">pch =</span> <span class="dv">16</span>
)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/slicer-vs-truth-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Like the previous method, SLICER here provides a good ordering for the early time points and struggles for later time points.</p>
<p><strong>Exercise 4</strong> How do the results change for different k? (e.g. k = 5) What about changing the number of nearest neighbours in the call to <code>conn_knn_graph</code>?</p>
<p><strong>Exercise 5</strong> How does the ordering change if you use a different set of genes from those chosen by SLICER (e.g. the genes identified by M3Drop)?</p>
</div>
<div id="comparison-of-the-methods" class="section level3">
<h3><span class="header-section-number">4.4.5</span> Comparison of the methods</h3>
<p>How do the trajectories inferred by TSCAN and Monocle compare?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">matched_ordering &lt;-
<span class="st">    </span><span class="kw">match</span>(
        pseudotime_order_tscan,
        pseudotime_order_monocle
    )
timepoint_ordered &lt;-
<span class="st">    </span>monocle_time_point[<span class="kw">order</span>(pseudotime_monocle<span class="op">$</span>pseudotime)]
<span class="kw">plot</span>(
    matched_ordering,
    <span class="dt">xlab =</span> <span class="st">&quot;Monocle Order&quot;</span>,
    <span class="dt">ylab =</span> <span class="st">&quot;TSCAN Order&quot;</span>,
    <span class="dt">col =</span> colours[timepoint_ordered],
    <span class="dt">pch =</span> <span class="dv">16</span>
)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/tscan-monocle-compare-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Exercise 6</strong>: Compare destiny and SLICER to TSCAN and Monocle.</p>
</div>
<div id="expression-of-genes-through-time" class="section level3">
<h3><span class="header-section-number">4.4.6</span> Expression of genes through time</h3>
<p>Each package also enables the visualization of expression through pseudotime. Following individual genes is very helpful for identifying genes that play an important role in the differentiation process. We illustrate the procedure using the <code>Rhoa</code> gene.</p>
<p><strong>TSCAN</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colnames</span>(deng) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(deng)
TSCAN<span class="op">::</span><span class="kw">singlegeneplot</span>(
    deng[<span class="kw">rownames</span>(deng) <span class="op">==</span><span class="st"> &quot;Rhoa&quot;</span>, ],
    dengorderTSCAN
)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/Rhoa-tscan-1.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Monocle</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">monocle<span class="op">::</span><span class="kw">plot_genes_in_pseudotime</span>(
    dCellDataSet[<span class="kw">fData</span>(dCellDataSet)<span class="op">$</span>gene <span class="op">==</span><span class="st"> &quot;Rhoa&quot;</span>,],
    <span class="dt">color_by =</span> <span class="st">&quot;timepoint&quot;</span>
)</code></pre></div>
<p><img src="20-pseudotime_files/figure-html/Rhoa-monocle-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Of course, pseudotime values computed with any method can be added to the <code>colData</code> slot of an <code>SCE</code> object. Having done that, the full plotting capabilities of the <code>scater</code> package can be used to investigate relationships between gene expression, cell populations and pseudotime. This would be particularly useful for the SLICER results, as SLICER does not provide plotting functions.</p>
<p><strong>Exercise 7</strong>: Repeat the exercise using a subset of the genes, e.g. the set of highly variable genes that can be obtained using <code>Brennecke_getVariableGenes()</code></p>
</div>
<div id="sessioninfo-11" class="section level3">
<h3><span class="header-section-number">4.4.7</span> sessionInfo()</h3>
<pre><code>## R version 3.4.2 (2017-09-28)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS/LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
##  [1] splines   parallel  stats4    methods   stats     graphics  grDevices
##  [8] utils     datasets  base     
## 
## other attached packages:
##  [1] lle_1.1                     snowfall_1.84-6.1          
##  [3] snow_0.4-2                  MASS_7.3-45                
##  [5] scatterplot3d_0.3-40        SLICER_0.2.0               
##  [7] destiny_2.4.5               monocle_2.4.0              
##  [9] DDRTree_0.1.5               irlba_2.3.1                
## [11] VGAM_1.0-4                  ggplot2_2.2.1              
## [13] Matrix_1.2-7.1              M3Drop_2.02.00             
## [15] numDeriv_2016.8-1           TSCAN_1.14.0               
## [17] SingleCellExperiment_0.99.4 SummarizedExperiment_1.6.5 
## [19] DelayedArray_0.2.7          matrixStats_0.52.2         
## [21] Biobase_2.36.2              GenomicRanges_1.28.6       
## [23] GenomeInfoDb_1.12.3         IRanges_2.10.5             
## [25] S4Vectors_0.14.7            BiocGenerics_0.22.1        
## [27] knitr_1.17                 
## 
## loaded via a namespace (and not attached):
##   [1] backports_1.1.1         Hmisc_4.0-3            
##   [3] RcppEigen_0.3.3.3.0     plyr_1.8.4             
##   [5] igraph_1.1.2            lazyeval_0.2.0         
##   [7] sp_1.2-5                densityClust_0.3       
##   [9] fastICA_1.2-1           digest_0.6.12          
##  [11] htmltools_0.3.6         gdata_2.18.0           
##  [13] magrittr_1.5            checkmate_1.8.5        
##  [15] tensor_1.5              cluster_2.0.6          
##  [17] limma_3.32.10           tripack_1.3-8          
##  [19] R.utils_2.5.0           xts_0.10-0             
##  [21] colorspace_1.3-2        ggrepel_0.7.0          
##  [23] dplyr_0.7.4             RCurl_1.95-4.8         
##  [25] lme4_1.1-14             spatstat_1.53-2        
##  [27] spatstat.data_1.1-1     bindr_0.1              
##  [29] survival_2.40-1         zoo_1.8-0              
##  [31] glue_1.1.1              polyclip_1.6-1         
##  [33] gtable_0.2.0            zlibbioc_1.22.0        
##  [35] XVector_0.16.0          MatrixModels_0.4-1     
##  [37] car_2.1-5               DEoptimR_1.0-8         
##  [39] abind_1.4-5             SparseM_1.77           
##  [41] VIM_4.7.0               scales_0.5.0           
##  [43] sgeostat_1.0-27         pheatmap_1.0.8         
##  [45] Rcpp_0.12.13            xtable_1.8-2           
##  [47] laeken_0.4.6            htmlTable_1.9          
##  [49] foreign_0.8-67          proxy_0.4-17           
##  [51] mclust_5.3              Formula_1.2-2          
##  [53] vcd_1.4-3               htmlwidgets_0.9        
##  [55] FNN_1.1                 gplots_3.0.1           
##  [57] RColorBrewer_1.1-2      acepack_1.4.1          
##  [59] pkgconfig_2.0.1         R.methodsS3_1.7.1      
##  [61] deldir_0.1-14           nnet_7.3-12            
##  [63] alphahull_2.1           labeling_0.3           
##  [65] rlang_0.1.2             reshape2_1.4.2         
##  [67] munsell_0.4.3           tools_3.4.2            
##  [69] splancs_2.01-40         evaluate_0.10.1        
##  [71] stringr_1.2.0           yaml_2.1.14            
##  [73] goftest_1.1-1           robustbase_0.92-7      
##  [75] caTools_1.17.1          bindrcpp_0.2           
##  [77] nlme_3.1-129            mime_0.5               
##  [79] quantreg_5.34           slam_0.1-40            
##  [81] R.oo_1.21.0             compiler_3.4.2         
##  [83] pbkrtest_0.4-7          curl_3.0               
##  [85] e1071_1.6-8             spatstat.utils_1.7-1   
##  [87] smoother_1.1            tibble_1.3.4           
##  [89] statmod_1.4.30          stringi_1.1.5          
##  [91] highr_0.6               lattice_0.20-34        
##  [93] nloptr_1.0.4            HSMMSingleCell_0.110.0 
##  [95] combinat_0.0-8          lmtest_0.9-35          
##  [97] data.table_1.10.4-3     bitops_1.0-6           
##  [99] httpuv_1.3.5            R6_2.2.2               
## [101] latticeExtra_0.6-28     bookdown_0.5           
## [103] KernSmooth_2.23-15      gridExtra_2.3          
## [105] boot_1.3-18             gtools_3.5.0           
## [107] assertthat_0.2.0        rprojroot_1.2          
## [109] qlcMatrix_0.9.5         GenomeInfoDbData_0.99.0
## [111] mgcv_1.8-22             grid_3.4.2             
## [113] rpart_4.1-10            class_7.3-14           
## [115] minqa_1.2.4             rmarkdown_1.6          
## [117] Rtsne_0.13              TTR_0.23-2             
## [119] bbmle_1.0.19            shiny_1.0.5            
## [121] base64enc_0.1-3</code></pre>

</div>
</div>
<div id="imputation" class="section level2">
<h2><span class="header-section-number">4.5</span> Imputation</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scImpute)
<span class="kw">library</span>(SC3)
<span class="kw">library</span>(scater)
<span class="kw">library</span>(SingleCellExperiment)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)</code></pre></div>
<p>As discussed previously, one of the main challenges when analyzing scRNA-seq data is the presence of zeros, or dropouts. The dropouts are assumed to have arisen for three possible reasons:</p>
<ul>
<li>The gene was not expressed in the cell and hence there are no transcripts to sequence</li>
<li>The gene was expressed, but for some reason the transcripts were lost somewhere prior to sequencing</li>
<li>The gene was expressed and transcripts were captured and turned into cDNA, but the sequencing depth was not sufficient to produce any reads.</li>
</ul>
<p>Thus, dropouts could be result of experimental shortcomings, and if this is the case then we would like to provide computational corrections. One possible solution is to impute the dropouts in the expression matrix. To be able to impute gene expression values, one must have an underlying model. However, since we do not know which dropout events are technical artefacts and which correspond to the transcript being truly absent, imputation is a difficult challenges.</p>
<p>To the best of our knowledge, there are currently two different imputation methods available: MAGIC <span class="citation">(Dijk et al. <a href="#ref-Van_Dijk2017-bh">2017</a>)</span> and scImpute <span class="citation">(W. V. Li and Li <a href="#ref-Li2017-tz">2017</a>)</span>. <a href="https://github.com/pkathail/magic">MAGIC</a> is only available for Python or Matlab, but we will run it from within R.</p>
<div id="scimpute" class="section level3">
<h3><span class="header-section-number">4.5.1</span> scImpute</h3>
<p>To test <code>scImpute</code>, we use the default parameters and we apply it to the Deng dataset that we have worked with before. scImpute takes a .csv or .txt file as an input:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">deng &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;deng/deng-reads.rds&quot;</span>)
<span class="kw">write.csv</span>(<span class="kw">counts</span>(deng), <span class="st">&quot;deng.csv&quot;</span>)
<span class="kw">scimpute</span>(
    <span class="dt">count_path =</span> <span class="st">&quot;deng.csv&quot;</span>,
    <span class="dt">infile =</span> <span class="st">&quot;csv&quot;</span>,
    <span class="dt">outfile =</span> <span class="st">&quot;txt&quot;</span>, 
    <span class="dt">out_dir =</span> <span class="st">&quot;./&quot;</span>,
    <span class="dt">Kcluster =</span> <span class="dv">10</span>,
    <span class="dt">ncores =</span> <span class="dv">2</span>
)</code></pre></div>
<pre><code>## [1] &quot;reading in raw count matrix ...&quot;
## [1] &quot;number of genes in raw count matrix 22431&quot;
## [1] &quot;number of cells in raw count matrix 268&quot;
## [1] &quot;inferring cell similarities ...&quot;
## [1] &quot;cluster sizes:&quot;
##  [1] 12  9 26  5  9 57 58 43 17 22
## [1] &quot;estimating dropout probability for type 1 ...&quot;
## [1] &quot;imputing dropout values for type 1 ...&quot;
## [1] &quot;estimating dropout probability for type 2 ...&quot;
## [1] &quot;imputing dropout values for type 2 ...&quot;
## [1] &quot;estimating dropout probability for type 3 ...&quot;
## [1] &quot;imputing dropout values for type 3 ...&quot;
## [1] &quot;estimating dropout probability for type 4 ...&quot;
## [1] &quot;imputing dropout values for type 4 ...&quot;
## [1] &quot;estimating dropout probability for type 5 ...&quot;
## [1] &quot;imputing dropout values for type 5 ...&quot;
## [1] &quot;estimating dropout probability for type 6 ...&quot;
## [1] &quot;imputing dropout values for type 6 ...&quot;
## [1] &quot;estimating dropout probability for type 7 ...&quot;
## [1] &quot;imputing dropout values for type 7 ...&quot;
## [1] &quot;estimating dropout probability for type 8 ...&quot;
## [1] &quot;imputing dropout values for type 8 ...&quot;
## [1] &quot;estimating dropout probability for type 9 ...&quot;
## [1] &quot;imputing dropout values for type 9 ...&quot;
## [1] &quot;estimating dropout probability for type 10 ...&quot;
## [1] &quot;imputing dropout values for type 10 ...&quot;
## [1] &quot;writing imputed count matrix ...&quot;</code></pre>
<pre><code>##  [1]  17  18  88 111 126 177 186 229 244 247</code></pre>
<p>Now we can compare the results with original data by considering a PCA plot</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;scimpute_count.txt&quot;</span>)
<span class="kw">colnames</span>(res) &lt;-<span class="st"> </span><span class="ot">NULL</span>
res &lt;-<span class="st"> </span><span class="kw">SingleCellExperiment</span>(
    <span class="dt">assays =</span> <span class="kw">list</span>(<span class="dt">logcounts =</span> <span class="kw">log2</span>(<span class="kw">as.matrix</span>(res) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)), 
    <span class="dt">colData =</span> <span class="kw">colData</span>(deng)
)
<span class="kw">plotPCA</span>(
    res, 
    <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>
)</code></pre></div>
<p><img src="21-imputation_files/figure-html/unnamed-chunk-4-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Compare this result to the original data in Chapter <a href="biological-analysis.html#clust-methods">4.2</a>. What are the most significant differences?</p>
<p>To evaluate the impact of the imputation, we use <code>SC3</code> to cluster the imputed matrix</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">sc3_estimate_k</span>(res)
<span class="kw">metadata</span>(res)<span class="op">$</span>sc3<span class="op">$</span>k_estimation</code></pre></div>
<pre><code>## [1] 6</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">sc3</span>(res, <span class="dt">ks =</span> <span class="dv">10</span>, <span class="dt">gene_filter =</span> <span class="ot">FALSE</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_plot_consensus</span>(
    res, 
    <span class="dt">k =</span> <span class="dv">10</span>, 
    <span class="dt">show_pdata =</span> <span class="st">&quot;cell_type2&quot;</span>
)</code></pre></div>
<p><img src="21-imputation_files/figure-html/unnamed-chunk-5-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(
    res, 
    <span class="dt">colour_by =</span> <span class="st">&quot;sc3_10_clusters&quot;</span>
)</code></pre></div>
<p><img src="21-imputation_files/figure-html/unnamed-chunk-5-2.png" width="672" style="display: block; margin: auto;" /></p>
<p><strong>Exercise:</strong> Based on the PCA and the clustering results, do you think that imputation using <code>scImpute</code> is a good idea for the Deng dataset?</p>
</div>
<div id="magic" class="section level3">
<h3><span class="header-section-number">4.5.2</span> MAGIC</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system</span>(<span class="st">&quot;python3 utils/MAGIC.py -d deng.csv -o MAGIC_count.csv --cell-axis columns -l 1 --pca-non-random csv&quot;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;MAGIC_count.csv&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)
<span class="kw">rownames</span>(res) &lt;-<span class="st"> </span>res[,<span class="dv">1</span>]
res &lt;-<span class="st"> </span>res[,<span class="op">-</span><span class="dv">1</span>]
res &lt;-<span class="st"> </span><span class="kw">t</span>(res)
res &lt;-<span class="st"> </span><span class="kw">SingleCellExperiment</span>(
    <span class="dt">assays =</span> <span class="kw">list</span>(<span class="dt">logcounts =</span> res), 
    <span class="dt">colData =</span> <span class="kw">colData</span>(deng)
)
<span class="kw">plotPCA</span>(
    res, 
    <span class="dt">colour_by =</span> <span class="st">&quot;cell_type2&quot;</span>
)</code></pre></div>
<p><img src="21-imputation_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Compare this result to the original data in Chapter <a href="biological-analysis.html#clust-methods">4.2</a>. What are the most significant differences?</p>
<p>To evaluate the impact of the imputation, we use <code>SC3</code> to cluster the imputed matrix</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">sc3_estimate_k</span>(res)
<span class="kw">metadata</span>(res)<span class="op">$</span>sc3<span class="op">$</span>k_estimation</code></pre></div>
<pre><code>## [1] 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">sc3</span>(res, <span class="dt">ks =</span> <span class="dv">10</span>, <span class="dt">gene_filter =</span> <span class="ot">FALSE</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc3_plot_consensus</span>(
    res, 
    <span class="dt">k =</span> <span class="dv">10</span>, 
    <span class="dt">show_pdata =</span> <span class="st">&quot;cell_type2&quot;</span>
)</code></pre></div>
<p><img src="21-imputation_files/figure-html/unnamed-chunk-8-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plotPCA</span>(
    res, 
    <span class="dt">colour_by =</span> <span class="st">&quot;sc3_10_clusters&quot;</span>
)</code></pre></div>
<p><img src="21-imputation_files/figure-html/unnamed-chunk-8-2.png" width="672" style="display: block; margin: auto;" /> <strong>Exercise:</strong> What is the difference between <code>scImpute</code> and <code>MAGIC</code> based on the PCA and clustering analysis? Which one do you think is best to use?</p>
</div>
<div id="sessioninfo-12" class="section level3">
<h3><span class="header-section-number">4.5.3</span> sessionInfo()</h3>
<pre><code>## R version 3.4.2 (2017-09-28)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS/LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats4    methods   parallel  stats     graphics  grDevices utils    
## [8] datasets  base     
## 
## other attached packages:
##  [1] scater_1.5.21               ggplot2_2.2.1              
##  [3] SC3_1.5.6                   SingleCellExperiment_0.99.4
##  [5] SummarizedExperiment_1.6.5  DelayedArray_0.2.7         
##  [7] matrixStats_0.52.2          Biobase_2.36.2             
##  [9] GenomicRanges_1.28.6        GenomeInfoDb_1.12.3        
## [11] IRanges_2.10.5              S4Vectors_0.14.7           
## [13] BiocGenerics_0.22.1         scImpute_0.0.4             
## [15] doParallel_1.0.11           iterators_1.0.8            
## [17] foreach_1.4.3               penalized_0.9-50           
## [19] survival_2.40-1             kernlab_0.9-25             
## [21] knitr_1.17                 
## 
## loaded via a namespace (and not attached):
##  [1] bitops_1.0-6            bit64_0.9-7            
##  [3] RColorBrewer_1.1-2      rprojroot_1.2          
##  [5] tools_3.4.2             backports_1.1.1        
##  [7] doRNG_1.6.6             R6_2.2.2               
##  [9] vipor_0.4.5             KernSmooth_2.23-15     
## [11] DBI_0.7                 lazyeval_0.2.0         
## [13] colorspace_1.3-2        gridExtra_2.3          
## [15] bit_1.1-12              compiler_3.4.2         
## [17] pkgmaker_0.22           labeling_0.3           
## [19] bookdown_0.5            caTools_1.17.1         
## [21] scales_0.5.0            DEoptimR_1.0-8         
## [23] mvtnorm_1.0-6           robustbase_0.92-7      
## [25] stringr_1.2.0           digest_0.6.12          
## [27] rmarkdown_1.6           XVector_0.16.0         
## [29] pkgconfig_2.0.1         rrcov_1.4-3            
## [31] htmltools_0.3.6         WriteXLS_4.0.0         
## [33] limma_3.32.10           rlang_0.1.2            
## [35] RSQLite_2.0             shiny_1.0.5            
## [37] bindr_0.1               gtools_3.5.0           
## [39] dplyr_0.7.4             RCurl_1.95-4.8         
## [41] magrittr_1.5            GenomeInfoDbData_0.99.0
## [43] Matrix_1.2-7.1          ggbeeswarm_0.6.0       
## [45] Rcpp_0.12.13            munsell_0.4.3          
## [47] viridis_0.4.0           edgeR_3.18.1           
## [49] stringi_1.1.5           yaml_2.1.14            
## [51] zlibbioc_1.22.0         rhdf5_2.20.0           
## [53] gplots_3.0.1            plyr_1.8.4             
## [55] grid_3.4.2              blob_1.1.0             
## [57] gdata_2.18.0            shinydashboard_0.6.1   
## [59] lattice_0.20-34         cowplot_0.8.0          
## [61] splines_3.4.2           locfit_1.5-9.1         
## [63] rjson_0.2.15            rngtools_1.2.4         
## [65] reshape2_1.4.2          codetools_0.2-15       
## [67] biomaRt_2.32.1          glue_1.1.1             
## [69] XML_3.98-1.9            evaluate_0.10.1        
## [71] data.table_1.10.4-3     httpuv_1.3.5           
## [73] gtable_0.2.0            assertthat_0.2.0       
## [75] mime_0.5                xtable_1.8-2           
## [77] e1071_1.6-8             class_7.3-14           
## [79] pcaPP_1.9-72            viridisLite_0.2.0      
## [81] tibble_1.3.4            pheatmap_1.0.8         
## [83] beeswarm_0.2.3          AnnotationDbi_1.38.2   
## [85] registry_0.3            memoise_1.1.0          
## [87] tximport_1.4.0          bindrcpp_0.2           
## [89] cluster_2.0.6           ROCR_1.0-7</code></pre>

</div>
</div>
<div id="dechapter" class="section level2">
<h2><span class="header-section-number">4.6</span> Differential Expression (DE) analysis</h2>
<div id="bulk-rna-seq-1" class="section level3">
<h3><span class="header-section-number">4.6.1</span> Bulk RNA-seq</h3>
<p>One of the most common types of analyses when analyzing bulk RNA-seq data is to identify differentially expressed genes. By comparing the genes that change between two conditions, e.g. mutant and wild-type or stimulated and unstimulated, it is possible to characterize the molecular mechanisms underlying the change.</p>
<p>Several different methods, e.g. <a href="https://bioconductor.org/packages/DESeq2">DESeq2</a> and <a href="https://bioconductor.org/packages/release/bioc/html/edgeR.html">edgeR</a>, have been developed for bulk RNA-seq. Moreover, there are also extensive <a href="http://genomebiology.biomedcentral.com/articles/10.1186/gb-2013-14-9-r95">datasets</a> available where the RNA-seq data has been validated using RT-qPCR. These data can be used to benchmark DE finding algorithms.</p>
</div>
<div id="single-cell-rna-seq" class="section level3">
<h3><span class="header-section-number">4.6.2</span> Single cell RNA-seq</h3>
<p>In contrast to bulk RNA-seq, in scRNA-seq we usually do not have a defined set of experimental conditions. Instead, as was shown in a previous chapter (<a href="biological-analysis.html#clust-methods">4.2</a>) we can identify the cell groups by using an unsupervised clustering approach. Once the groups have been identified one can find differentially expressed genes either by comparing the differences in variance between the groups (like the Kruskal-Wallis test implemented in SC3), or by comparing gene expression between clusters in a pairwise manner. In the following chapter we will mainly consider tools developed for pairwise comparisons.</p>
</div>
<div id="differences-in-distribution" class="section level3">
<h3><span class="header-section-number">4.6.3</span> Differences in Distribution</h3>
<p>Unlike bulk RNA-seq, we generally have a large number of samples (i.e. cells) for each group we are comparing in single-cell experiments. Thus we can take advantage of the whole distribution of expression values in each group to identify differences between groups rather than only comparing estimates of mean-expression as is standard for bulk RNASeq.</p>
<p>There are two main approaches to comparing distributions. Firstly, we can use existing statistical models/distributions and fit the same type of model to the expression in each group then test for differences in the parameters for each model, or test whether the model fits better if a particular paramter is allowed to be different according to group. For instance in Chapter <a href="construction-of-expression-matrix.html#dealing-with-confounders">3.17</a> we used edgeR to test whether allowing mean expression to be different in different batches significantly improved the fit of a negative binomial model of the data.</p>
<p>Alternatively, we can use a non-parametric test which does not assume expression values follow any particular distribution, e.g. the <a href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">Kolmogorov-Smirnov test (KS-test)</a>. Non-parametric tests generally convert observed expression values to ranks and test whether the distribution of ranks for one group are signficantly different from the distribution of ranks for the other group. However, some non-parametric methods fail in the presence of a large number of tied values, such as the case for dropouts (zeros) in single-cell RNA-seq expression data. Moreover, if the conditions for a parametric test hold, then it will typically be more powerful than a non-parametric test.</p>
</div>
<div id="models-of-single-cell-rnaseq-data" class="section level3">
<h3><span class="header-section-number">4.6.4</span> Models of single-cell RNASeq data</h3>
<p>The most common model of RNASeq data is the negative binomial model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
<span class="kw">hist</span>(
    <span class="kw">rnbinom</span>(
        <span class="dv">1000</span>, 
        <span class="dt">mu =</span> <span class="dv">10</span>, 
        <span class="dt">size =</span> <span class="dv">100</span>), 
    <span class="dt">col =</span> <span class="st">&quot;grey50&quot;</span>, 
    <span class="dt">xlab =</span> <span class="st">&quot;Read Counts&quot;</span>, 
    <span class="dt">main =</span> <span class="st">&quot;Negative Binomial&quot;</span>
)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:nb-plot"></span>
<img src="22-de-intro_files/figure-html/nb-plot-1.png" alt="Negative Binomial distribution of read counts for a single gene across 1000 cells" width="672" />
<p class="caption">
Figure 4.12: Negative Binomial distribution of read counts for a single gene across 1000 cells
</p>
</div>
<p>Mean: <span class="math inline">\(\mu = mu\)</span></p>
<p>Variance: <span class="math inline">\(\sigma^2 = mu + mu^2/size\)</span></p>
<p>It is parameterized by the mean expression (mu) and the dispersion (size), which is inversely related to the variance. The negative binomial model fits bulk RNA-seq data very well and it is used for most statistical methods designed for such data. In addition, it has been show to fit the distribution of molecule counts obtained from data tagged by unique molecular identifiers (UMIs) quite well (<a href="http://www.nature.com/nmeth/journal/v11/n6/full/nmeth.2930.html">Grun et al. 2014</a>, <a href="http://genome.cshlp.org/content/21/7/1160">Islam et al. 2011</a>).</p>
<p>However, a raw negative binomial model does not fit full-length transcript data as well due to the high dropout rates relative to the non-zero read counts. For this type of data a variety of zero-inflated negative binomial models have been proposed (e.g. <a href="https://bioconductor.org/packages/release/bioc/html/MAST.html">MAST</a>, <a href="https://bioconductor.org/packages/release/bioc/html/scde.html">SCDE</a>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d &lt;-<span class="st"> </span><span class="fl">0.5</span>;
counts &lt;-<span class="st"> </span><span class="kw">rnbinom</span>(
    <span class="dv">1000</span>, 
    <span class="dt">mu =</span> <span class="dv">10</span>, 
    <span class="dt">size =</span> <span class="dv">100</span>
)
counts[<span class="kw">runif</span>(<span class="dv">1000</span>) <span class="op">&lt;</span><span class="st"> </span>d] &lt;-<span class="st"> </span><span class="dv">0</span>
<span class="kw">hist</span>(
    counts, 
    <span class="dt">col =</span> <span class="st">&quot;grey50&quot;</span>, 
    <span class="dt">xlab =</span> <span class="st">&quot;Read Counts&quot;</span>, 
    <span class="dt">main =</span> <span class="st">&quot;Zero-inflated NB&quot;</span>
)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:zero-inflation-plot"></span>
<img src="22-de-intro_files/figure-html/zero-inflation-plot-1.png" alt="Zero-inflated Negative Binomial distribution" width="672" />
<p class="caption">
Figure 4.13: Zero-inflated Negative Binomial distribution
</p>
</div>
<p>Mean: <span class="math inline">\(\mu = mu \cdot (1 - d)\)</span></p>
<p>Variance: <span class="math inline">\(\sigma^2 = \mu \cdot (1-d) \cdot (1 + d \cdot \mu + \mu / size)\)</span></p>
<p>These models introduce a new parameter <span class="math inline">\(d\)</span>, for the dropout rate, to the negative binomial model. As we saw in Chapter 19, the dropout rate of a gene is strongly correlated with the mean expression of the gene. Different zero-inflated negative binomial models use different relationships between mu and d and some may fit <span class="math inline">\(\mu\)</span> and <span class="math inline">\(d\)</span> to the expression of each gene independently.</p>
<p>Finally, several methods use a Poisson-Beta distribution which is based on a mechanistic model of transcriptional bursting. There is strong experimental support for this model (<a href="https://genomebiology.biomedcentral.com/articles/10.1186/gb-2013-14-1-r7">Kim and Marioni, 2013</a>) and it provides a good fit to scRNA-seq data but it is less easy to use than the negative-binomial models and much less existing methods upon which to build than the negative binomial model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="fl">0.1</span>
b &lt;-<span class="st"> </span><span class="fl">0.1</span>
g &lt;-<span class="st"> </span><span class="dv">100</span>
lambdas &lt;-<span class="st"> </span><span class="kw">rbeta</span>(<span class="dv">1000</span>, a, b)
counts &lt;-<span class="st"> </span><span class="kw">sapply</span>(g<span class="op">*</span>lambdas, <span class="cf">function</span>(l) {<span class="kw">rpois</span>(<span class="dv">1</span>, <span class="dt">lambda =</span> l)})
<span class="kw">hist</span>(
    counts, 
    <span class="dt">col =</span> <span class="st">&quot;grey50&quot;</span>, 
    <span class="dt">xlab =</span> <span class="st">&quot;Read Counts&quot;</span>, 
    <span class="dt">main =</span> <span class="st">&quot;Poisson-Beta&quot;</span>
)</code></pre></div>
<p><img src="22-de-intro_files/figure-html/pois-beta-plot-1.png" width="672" style="display: block; margin: auto;" /> Mean: <span class="math inline">\(\mu = g \cdot a / (a + b)\)</span></p>
<p>Variance: <span class="math inline">\(\sigma^2 = g^2 \cdot a \cdot b/((a + b + 1) \cdot (a + b)^2)\)</span></p>
<p>This model uses three parameters: <span class="math inline">\(a\)</span> the rate of activation of transcription; <span class="math inline">\(b\)</span> the rate of inhibition of transcription; and <span class="math inline">\(g\)</span> the rate of transcript production while transcription is active at the locus. Differential expression methods may test each of the parameters for differences across groups or only one (often <span class="math inline">\(g\)</span>).</p>
<p>All of these models may be further expanded to explicitly account for other sources of gene expression differences such as batch-effect or library depth depending on the particular DE algorithm.</p>
<p><strong>Exercise</strong>: Vary the parameters of each distribution to explore how they affect the distribution of gene expression. How similar are the Poisson-Beta and Negative Binomial models?</p>

</div>
</div>
<div id="de-in-a-real-dataset" class="section level2">
<h2><span class="header-section-number">4.7</span> DE in a real dataset</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scRNA.seq.funcs)
<span class="kw">library</span>(edgeR)
<span class="kw">library</span>(monocle)
<span class="kw">library</span>(MAST)
<span class="kw">library</span>(ROCR)
<span class="kw">set.seed</span>(<span class="dv">1</span>)</code></pre></div>
<div id="introduction-7" class="section level3">
<h3><span class="header-section-number">4.7.1</span> Introduction</h3>
<p>To test different single-cell differential expression methods we will be using the Blischak dataset from Chapters 7-17. For this experiment bulk RNA-seq data for each cell-line was generated in addition to single-cell data. We will use the differentially expressed genes identified using standard methods on the respective bulk data as the ground truth for evaluating the accuracy of each single-cell method. To save time we have pre-computed these for you, run the commands below to load these data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DE &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;tung/TPs.txt&quot;</span>)
notDE &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;tung/TNs.txt&quot;</span>)
GroundTruth &lt;-<span class="st"> </span><span class="kw">list</span>(
    <span class="dt">DE =</span> <span class="kw">as.character</span>(<span class="kw">unlist</span>(DE)), 
    <span class="dt">notDE =</span> <span class="kw">as.character</span>(<span class="kw">unlist</span>(notDE))
)</code></pre></div>
<p>This ground truth has been produce for the comparison of individual NA19101 to NA19239. Now load the respective single-cell data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">molecules &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;tung/molecules.txt&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>)
anno &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;tung/annotation.txt&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)
keep &lt;-<span class="st"> </span>anno[,<span class="dv">1</span>] <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span> <span class="op">|</span><span class="st"> </span>anno[,<span class="dv">1</span>] <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>
data &lt;-<span class="st"> </span>molecules[,keep]
group &lt;-<span class="st"> </span>anno[keep,<span class="dv">1</span>]
batch &lt;-<span class="st"> </span>anno[keep,<span class="dv">4</span>]
<span class="co"># remove genes that aren&#39;t expressed in at least 6 cells</span>
gkeep &lt;-<span class="st"> </span><span class="kw">rowSums</span>(data <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span>;
counts &lt;-<span class="st"> </span>data[gkeep,]
<span class="co"># Library size normalization</span>
lib_size =<span class="st"> </span><span class="kw">colSums</span>(counts)
norm &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">t</span>(counts)<span class="op">/</span>lib_size <span class="op">*</span><span class="st"> </span><span class="kw">median</span>(lib_size)) 
<span class="co"># Variant of CPM for datasets with library sizes of fewer than 1 mil molecules</span></code></pre></div>
<p>Now we will compare various single-cell DE methods. Note that we will only be running methods which are available as R-packages and run relatively quickly.</p>
</div>
<div id="kolmogorov-smirnov-test" class="section level3">
<h3><span class="header-section-number">4.7.2</span> Kolmogorov-Smirnov test</h3>
<p>The types of test that are easiest to work with are non-parametric ones. The most commonly used non-parametric test is the <a href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">Kolmogorov-Smirnov test</a> (KS-test) and we can use it to compare the distributions for each gene in the two individuals.</p>
<p>The KS-test quantifies the distance between the empirical cummulative distributions of the expression of each gene in each of the two populations. It is sensitive to changes in mean experession and changes in variability. However it assumes data is continuous and may perform poorly when data contains a large number of identical values (eg. zeros). Another issue with the KS-test is that it can be very sensitive for large sample sizes and thus it may end up as significant even though the magnitude of the difference is very small.</p>
<div class="figure" style="text-align: center"><span id="fig:ks-statistic"></span>
<img src="figures/KS2_Example.png" alt="Illustration of the two-sample Kolmogorov–Smirnov statistic. Red and blue lines each correspond to an empirical distribution function, and the black arrow is the two-sample KS statistic. (taken from [here](https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test))" width="60%" />
<p class="caption">
Figure 4.14: Illustration of the two-sample Kolmogorov–Smirnov statistic. Red and blue lines each correspond to an empirical distribution function, and the black arrow is the two-sample KS statistic. (taken from <a href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">here</a>)
</p>
</div>
<p>Now run the test:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pVals &lt;-<span class="st"> </span><span class="kw">apply</span>(
    norm, <span class="dv">1</span>, <span class="cf">function</span>(x) {
        <span class="kw">ks.test</span>(
            x[group <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>], 
            x[group <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>]
        )<span class="op">$</span>p.value
    }
)
<span class="co"># multiple testing correction</span>
pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)</code></pre></div>
<p>This code “applies” the function to each row (specified by 1) of the expression matrix, data. In the function we are returning just the p.value from the ks.test output. We can now consider how many of the ground truth positive and negative DE genes are detected by the KS-test:</p>
<div id="evaluating-accuracy" class="section level4">
<h4><span class="header-section-number">4.7.2.1</span> Evaluating Accuracy</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sigDE &lt;-<span class="st"> </span><span class="kw">names</span>(pVals)[pVals <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.05</span>]
<span class="kw">length</span>(sigDE) </code></pre></div>
<pre><code>## [1] 5095</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Number of KS-DE genes</span>
<span class="kw">sum</span>(GroundTruth<span class="op">$</span>DE <span class="op">%in%</span><span class="st"> </span>sigDE) </code></pre></div>
<pre><code>## [1] 792</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Number of KS-DE genes that are true DE genes</span>
<span class="kw">sum</span>(GroundTruth<span class="op">$</span>notDE <span class="op">%in%</span><span class="st"> </span>sigDE)</code></pre></div>
<pre><code>## [1] 3190</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Number of KS-DE genes that are truly not-DE</span></code></pre></div>
<p>As you can see many more of our ground truth negative genes were identified as DE by the KS-test (false positives) than ground truth positive genes (true positives), however this may be due to the larger number of notDE genes thus we typically normalize these counts as the True positive rate (TPR), TP/(TP + FN), and False positive rate (FPR), FP/(FP+TP).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tp &lt;-<span class="st"> </span><span class="kw">sum</span>(GroundTruth<span class="op">$</span>DE <span class="op">%in%</span><span class="st"> </span>sigDE)
fp &lt;-<span class="st"> </span><span class="kw">sum</span>(GroundTruth<span class="op">$</span>notDE <span class="op">%in%</span><span class="st"> </span>sigDE)
tn &lt;-<span class="st"> </span><span class="kw">sum</span>(GroundTruth<span class="op">$</span>notDE <span class="op">%in%</span><span class="st"> </span><span class="kw">names</span>(pVals)[pVals <span class="op">&gt;=</span><span class="st"> </span><span class="fl">0.05</span>])
fn &lt;-<span class="st"> </span><span class="kw">sum</span>(GroundTruth<span class="op">$</span>DE <span class="op">%in%</span><span class="st"> </span><span class="kw">names</span>(pVals)[pVals <span class="op">&gt;=</span><span class="st"> </span><span class="fl">0.05</span>])
tpr &lt;-<span class="st"> </span>tp<span class="op">/</span>(tp <span class="op">+</span><span class="st"> </span>fn)
fpr &lt;-<span class="st"> </span>fp<span class="op">/</span>(fp <span class="op">+</span><span class="st"> </span>tn)
<span class="kw">cat</span>(<span class="kw">c</span>(tpr, fpr))</code></pre></div>
<pre><code>## 0.7346939 0.2944706</code></pre>
<p>Now we can see the TPR is much higher than the FPR indicating the KS test is identifying DE genes.</p>
<p>So far we’ve only evaluated the performance at a single significance threshold. Often it is informative to vary the threshold and evaluate performance across a range of values. This is then plotted as a receiver-operating-characteristic curve (ROC) and a general accuracy statistic can be calculated as the area under this curve (AUC). We will use the ROCR package to facilitate this plotting.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Only consider genes for which we know the ground truth</span>
pVals &lt;-<span class="st"> </span>pVals[<span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>DE <span class="op">|</span><span class="st"> </span>
<span class="st">               </span><span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>notDE] 
truth &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>, <span class="dt">times =</span> <span class="kw">length</span>(pVals));
truth[<span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>DE] =<span class="st"> </span><span class="dv">0</span>;
pred &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">prediction</span>(pVals, truth)
perf &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">performance</span>(pred, <span class="st">&quot;tpr&quot;</span>, <span class="st">&quot;fpr&quot;</span>)
ROCR<span class="op">::</span><span class="kw">plot</span>(perf)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:ks-roc-plot"></span>
<img src="23-de-real_files/figure-html/ks-roc-plot-1.png" alt="ROC curve for KS-test." width="672" />
<p class="caption">
Figure 4.15: ROC curve for KS-test.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">aucObj &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">performance</span>(pred, <span class="st">&quot;auc&quot;</span>)
aucObj<span class="op">@</span>y.values[[<span class="dv">1</span>]] <span class="co"># AUC</span></code></pre></div>
<pre><code>## [1] 0.7954796</code></pre>
<p>Finally to facilitate the comparisons of other DE methods let’s put this code into a function so we don’t need to repeat it:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DE_Quality_AUC &lt;-<span class="st"> </span><span class="cf">function</span>(pVals) {
    pVals &lt;-<span class="st"> </span>pVals[<span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>DE <span class="op">|</span><span class="st"> </span>
<span class="st">                   </span><span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>notDE]
    truth &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>, <span class="dt">times =</span> <span class="kw">length</span>(pVals));
    truth[<span class="kw">names</span>(pVals) <span class="op">%in%</span><span class="st"> </span>GroundTruth<span class="op">$</span>DE] =<span class="st"> </span><span class="dv">0</span>;
    pred &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">prediction</span>(pVals, truth)
    perf &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">performance</span>(pred, <span class="st">&quot;tpr&quot;</span>, <span class="st">&quot;fpr&quot;</span>)
    ROCR<span class="op">::</span><span class="kw">plot</span>(perf)
    aucObj &lt;-<span class="st"> </span>ROCR<span class="op">::</span><span class="kw">performance</span>(pred, <span class="st">&quot;auc&quot;</span>)
    <span class="kw">return</span>(aucObj<span class="op">@</span>y.values[[<span class="dv">1</span>]])
}</code></pre></div>
</div>
</div>
<div id="wilcoxmann-whitney-u-test" class="section level3">
<h3><span class="header-section-number">4.7.3</span> Wilcox/Mann-Whitney-U Test</h3>
<p>The Wilcox-rank-sum test is another non-parametric test, but tests specifically if values in one group are greater/less than the values in the other group. Thus it is often considered a test for difference in median expression between two groups; whereas the KS-test is sensitive to any change in distribution of expression values.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pVals &lt;-<span class="st"> </span><span class="kw">apply</span>(
    norm, <span class="dv">1</span>, <span class="cf">function</span>(x) {
        <span class="kw">wilcox.test</span>(
            x[group <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>], 
            x[group <span class="op">==</span><span class="st"> &quot;NA19239&quot;</span>]
        )<span class="op">$</span>p.value
    }
)
<span class="co"># multiple testing correction</span>
pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:wilcox-plot"></span>
<img src="23-de-real_files/figure-html/wilcox-plot-1.png" alt="ROC curve for Wilcox test." width="672" />
<p class="caption">
Figure 4.16: ROC curve for Wilcox test.
</p>
</div>
<pre><code>## [1] 0.8320326</code></pre>
</div>
<div id="edger" class="section level3">
<h3><span class="header-section-number">4.7.4</span> edgeR</h3>
<p>We’ve already used edgeR for differential expression in Chapter <a href="construction-of-expression-matrix.html#dealing-with-confounders">3.17</a>. edgeR is based on a negative binomial model of gene expression and uses a generalized linear model (GLM) framework, the enables us to include other factors such as batch to the model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dge &lt;-<span class="st"> </span><span class="kw">DGEList</span>(
    <span class="dt">counts =</span> counts, 
    <span class="dt">norm.factors =</span> <span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">length</span>(counts[<span class="dv">1</span>,])), 
    <span class="dt">group =</span> group
)
group_edgeR &lt;-<span class="st"> </span><span class="kw">factor</span>(group)
design &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span><span class="st"> </span>group_edgeR)
dge &lt;-<span class="st"> </span><span class="kw">estimateDisp</span>(dge, <span class="dt">design =</span> design, <span class="dt">trend.method =</span> <span class="st">&quot;none&quot;</span>)
fit &lt;-<span class="st"> </span><span class="kw">glmFit</span>(dge, design)
res &lt;-<span class="st"> </span><span class="kw">glmLRT</span>(fit)
pVals &lt;-<span class="st"> </span>res<span class="op">$</span>table[,<span class="dv">4</span>]
<span class="kw">names</span>(pVals) &lt;-<span class="st"> </span><span class="kw">rownames</span>(res<span class="op">$</span>table)

pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:edger-plot"></span>
<img src="23-de-real_files/figure-html/edger-plot-1.png" alt="ROC curve for edgeR." width="672" />
<p class="caption">
Figure 4.17: ROC curve for edgeR.
</p>
</div>
<pre><code>## [1] 0.8477189</code></pre>
</div>
<div id="monocle-1" class="section level3">
<h3><span class="header-section-number">4.7.5</span> Monocle</h3>
<p><a href="https://bioconductor.org/packages/release/bioc/html/monocle.html">Monocle</a> can use several different models for DE. For count data it recommends the Negative Binomial model (negbinomial.size). For normalized data it recommends log-transforming it then using a normal distribution (gaussianff). Similar to edgeR this method uses a GLM framework so in theory can account for batches, however in practice the model fails for this dataset if batches are included.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pd &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">group =</span> group, <span class="dt">batch =</span> batch)
<span class="kw">rownames</span>(pd) &lt;-<span class="st"> </span><span class="kw">colnames</span>(counts)
pd &lt;-<span class="st"> </span><span class="kw">new</span>(<span class="st">&quot;AnnotatedDataFrame&quot;</span>, <span class="dt">data =</span> pd)

Obj &lt;-<span class="st"> </span><span class="kw">newCellDataSet</span>(
    <span class="kw">as.matrix</span>(counts), 
    <span class="dt">phenoData =</span> pd, 
    <span class="dt">expressionFamily =</span> <span class="kw">negbinomial.size</span>()
)
Obj &lt;-<span class="st"> </span><span class="kw">estimateSizeFactors</span>(Obj)
Obj &lt;-<span class="st"> </span><span class="kw">estimateDispersions</span>(Obj)
res &lt;-<span class="st"> </span><span class="kw">differentialGeneTest</span>(Obj, <span class="dt">fullModelFormulaStr =</span> <span class="st">&quot;~group&quot;</span>)

pVals &lt;-<span class="st"> </span>res[,<span class="dv">3</span>]
<span class="kw">names</span>(pVals) &lt;-<span class="st"> </span><span class="kw">rownames</span>(res)
pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:Monocle-plot"></span>
<img src="23-de-real_files/figure-html/Monocle-plot-1.png" alt="ROC curve for Monocle." width="672" />
<p class="caption">
Figure 4.18: ROC curve for Monocle.
</p>
</div>
<pre><code>## [1] 0.8252662</code></pre>
<p><strong>Exercise</strong>: Compare the results using the negative binomial model on counts and those from using the normal/gaussian model (<code>gaussianff()</code>) on log-transformed normalized counts.</p>
<strong>Answer</strong>:
<div class="figure" style="text-align: center"><span id="fig:Monocle-plot2"></span>
<img src="23-de-real_files/figure-html/Monocle-plot2-1.png" alt="ROC curve for Monocle-gaussian." width="672" />
<p class="caption">
Figure 4.19: ROC curve for Monocle-gaussian.
</p>
</div>
<pre><code>## [1] 0.7357829</code></pre>
</div>
<div id="mast" class="section level3">
<h3><span class="header-section-number">4.7.6</span> MAST</h3>
<p><a href="https://bioconductor.org/packages/release/bioc/html/MAST.html">MAST</a> is based on a zero-inflated negative binomial model. It tests for differential expression using a hurdle model to combine tests of discrete (0 vs not zero) and continuous (non-zero values) aspects of gene expression. Again this uses a linear modelling framework to enable complex models to be considered.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">log_counts &lt;-<span class="st"> </span><span class="kw">log</span>(counts <span class="op">+</span><span class="st"> </span><span class="dv">1</span>) <span class="op">/</span><span class="st"> </span><span class="kw">log</span>(<span class="dv">2</span>)
fData &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">names =</span> <span class="kw">rownames</span>(log_counts))
<span class="kw">rownames</span>(fData) &lt;-<span class="st"> </span><span class="kw">rownames</span>(log_counts);
cData &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">cond =</span> group)
<span class="kw">rownames</span>(cData) &lt;-<span class="st"> </span><span class="kw">colnames</span>(log_counts)

obj &lt;-<span class="st"> </span><span class="kw">FromMatrix</span>(<span class="kw">as.matrix</span>(log_counts), cData, fData)
<span class="kw">colData</span>(obj)<span class="op">$</span>cngeneson &lt;-<span class="st"> </span><span class="kw">scale</span>(<span class="kw">colSums</span>(<span class="kw">assay</span>(obj) <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>))
cond &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">colData</span>(obj)<span class="op">$</span>cond)

<span class="co"># Model expression as function of condition &amp; number of detected genes</span>
zlmCond &lt;-<span class="st"> </span><span class="kw">zlm.SingleCellAssay</span>(<span class="op">~</span><span class="st"> </span>cond <span class="op">+</span><span class="st"> </span>cngeneson, obj) </code></pre></div>
<pre><code>## Warning: &#39;zlm.SingleCellAssay&#39; is deprecated.
## Use &#39;zlm&#39; instead.
## See help(&quot;Deprecated&quot;)</code></pre>
<pre><code>## Warning in .nextMethod(object = object, value = value): Coefficients
## condNA19239 are never estimible and will be dropped.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">summaryCond &lt;-<span class="st"> </span><span class="kw">summary</span>(zlmCond, <span class="dt">doLRT =</span> <span class="st">&quot;condNA19101&quot;</span>)
summaryDt &lt;-<span class="st"> </span>summaryCond<span class="op">$</span>datatable

summaryDt &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(summaryDt)
pVals &lt;-<span class="st"> </span><span class="kw">unlist</span>(summaryDt[summaryDt<span class="op">$</span>component <span class="op">==</span><span class="st"> &quot;H&quot;</span>,<span class="dv">4</span>]) <span class="co"># H = hurdle model</span>
<span class="kw">names</span>(pVals) &lt;-<span class="st"> </span><span class="kw">unlist</span>(summaryDt[summaryDt<span class="op">$</span>component <span class="op">==</span><span class="st"> &quot;H&quot;</span>,<span class="dv">1</span>])
pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:MAST-plot"></span>
<img src="23-de-real_files/figure-html/MAST-plot-1.png" alt="ROC curve for MAST." width="672" />
<p class="caption">
Figure 4.20: ROC curve for MAST.
</p>
</div>
<pre><code>## [1] 0.8284046</code></pre>
</div>
<div id="slow-methods-1h-to-run" class="section level3">
<h3><span class="header-section-number">4.7.7</span> Slow Methods (&gt;1h to run)</h3>
<p>These methods are too slow to run today but we encourage you to try them out on your own:</p>
</div>
<div id="bpsc" class="section level3">
<h3><span class="header-section-number">4.7.8</span> BPSC</h3>
<p><a href="https://academic.oup.com/bioinformatics/article/32/14/2128/2288270/Beta-Poisson-model-for-single-cell-RNA-seq-data">BPSC</a> uses the Poisson-Beta model of single-cell gene expression, which we discussed in the previous chapter, and combines it with generalized linear models which we’ve already encountered when using edgeR. BPSC performs comparisons of one or more groups to a reference group (“control”) and can include other factors such as batches in the model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(BPSC)
bpsc_data &lt;-<span class="st"> </span>norm[,batch<span class="op">==</span><span class="st">&quot;NA19101.r1&quot;</span> <span class="op">|</span><span class="st"> </span>batch<span class="op">==</span><span class="st">&quot;NA19239.r1&quot;</span>]
bpsc_group =<span class="st"> </span>group[batch<span class="op">==</span><span class="st">&quot;NA19101.r1&quot;</span> <span class="op">|</span><span class="st"> </span>batch<span class="op">==</span><span class="st">&quot;NA19239.r1&quot;</span>]

control_cells &lt;-<span class="st"> </span><span class="kw">which</span>(bpsc_group <span class="op">==</span><span class="st"> &quot;NA19101&quot;</span>)
design &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span>bpsc_group)
coef=<span class="dv">2</span> <span class="co"># group label</span>
res=<span class="kw">BPglm</span>(<span class="dt">data=</span>bpsc_data, <span class="dt">controlIds=</span>control_cells, <span class="dt">design=</span>design, <span class="dt">coef=</span>coef, 
                <span class="dt">estIntPar=</span><span class="ot">FALSE</span>, <span class="dt">useParallel =</span> <span class="ot">FALSE</span>)
pVals =<span class="st"> </span>res<span class="op">$</span>PVAL
pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
</div>
<div id="scde" class="section level3">
<h3><span class="header-section-number">4.7.9</span> SCDE</h3>
<p><a href="http://hms-dbmi.github.io/scde/">SCDE</a> is the first single-cell specific DE method. It fits a zero-inflated negative binomial model to expression data using Bayesian statistics. The usage below tests for differences in mean expression of individual genes across groups but recent versions include methods to test for differences in mean expression or dispersion of groups of genes, usually representing a pathway.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scde)
cnts &lt;-<span class="st"> </span><span class="kw">apply</span>(
    counts,
    <span class="dv">2</span>,
    <span class="cf">function</span>(x) {
        <span class="kw">storage.mode</span>(x) &lt;-<span class="st"> &#39;integer&#39;</span>
        <span class="kw">return</span>(x)
    }
)
<span class="kw">names</span>(group) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(group)
<span class="kw">colnames</span>(cnts) &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(group)
o.ifm &lt;-<span class="st"> </span>scde<span class="op">::</span><span class="kw">scde.error.models</span>(
    <span class="dt">counts =</span> cnts,
    <span class="dt">groups =</span> group,
    <span class="dt">n.cores =</span> <span class="dv">1</span>,
    <span class="dt">threshold.segmentation =</span> <span class="ot">TRUE</span>,
    <span class="dt">save.crossfit.plots =</span> <span class="ot">FALSE</span>,
    <span class="dt">save.model.plots =</span> <span class="ot">FALSE</span>,
    <span class="dt">verbose =</span> <span class="dv">0</span>,
    <span class="dt">min.size.entries =</span> <span class="dv">2</span>
)
priors &lt;-<span class="st"> </span>scde<span class="op">::</span><span class="kw">scde.expression.prior</span>(
    <span class="dt">models =</span> o.ifm,
    <span class="dt">counts =</span> cnts,
    <span class="dt">length.out =</span> <span class="dv">400</span>,
    <span class="dt">show.plot =</span> <span class="ot">FALSE</span>
)
resSCDE &lt;-<span class="st"> </span>scde<span class="op">::</span><span class="kw">scde.expression.difference</span>(
    o.ifm,
    cnts,
    priors,
    <span class="dt">groups =</span> group,
    <span class="dt">n.randomizations =</span> <span class="dv">100</span>,
    <span class="dt">n.cores =</span> <span class="dv">1</span>,
    <span class="dt">verbose =</span> <span class="dv">0</span>
)
<span class="co"># Convert Z-scores into 2-tailed p-values</span>
pVals &lt;-<span class="st"> </span><span class="kw">pnorm</span>(<span class="kw">abs</span>(resSCDE<span class="op">$</span>cZ), <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>) <span class="op">*</span><span class="st"> </span><span class="dv">2</span>
pVals &lt;-<span class="st"> </span><span class="kw">p.adjust</span>(pVals, <span class="dt">method =</span> <span class="st">&quot;fdr&quot;</span>)
<span class="kw">DE_Quality_AUC</span>(pVals)</code></pre></div>
</div>
<div id="sessioninfo-13" class="section level3">
<h3><span class="header-section-number">4.7.10</span> sessionInfo()</h3>
<pre><code>## R version 3.4.2 (2017-09-28)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS/LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
##  [1] splines   stats4    parallel  methods   stats     graphics  grDevices
##  [8] utils     datasets  base     
## 
## other attached packages:
##  [1] ROCR_1.0-7                 gplots_3.0.1              
##  [3] MAST_1.2.1                 SummarizedExperiment_1.6.5
##  [5] DelayedArray_0.2.7         matrixStats_0.52.2        
##  [7] GenomicRanges_1.28.6       GenomeInfoDb_1.12.3       
##  [9] IRanges_2.10.5             S4Vectors_0.14.7          
## [11] monocle_2.4.0              DDRTree_0.1.5             
## [13] irlba_2.3.1                VGAM_1.0-4                
## [15] ggplot2_2.2.1              Biobase_2.36.2            
## [17] BiocGenerics_0.22.1        Matrix_1.2-7.1            
## [19] edgeR_3.18.1               limma_3.32.10             
## [21] scRNA.seq.funcs_0.1.0      knitr_1.17                
## 
## loaded via a namespace (and not attached):
##  [1] gtools_3.5.0            elliptic_1.3-7         
##  [3] moments_0.14            assertthat_0.2.0       
##  [5] statmod_1.4.30          highr_0.6              
##  [7] GenomeInfoDbData_0.99.0 yaml_2.1.14            
##  [9] slam_0.1-40             ggrepel_0.7.0          
## [11] backports_1.1.1         lattice_0.20-34        
## [13] glue_1.1.1              densityClust_0.3       
## [15] digest_0.6.12           RColorBrewer_1.1-2     
## [17] XVector_0.16.0          colorspace_1.3-2       
## [19] fastICA_1.2-1           htmltools_0.3.6        
## [21] plyr_1.8.4              pkgconfig_2.0.1        
## [23] pheatmap_1.0.8          HSMMSingleCell_0.110.0 
## [25] qlcMatrix_0.9.5         zlibbioc_1.22.0        
## [27] bookdown_0.5            scales_0.5.0           
## [29] gdata_2.18.0            Rtsne_0.13             
## [31] tibble_1.3.4            combinat_0.0-8         
## [33] lazyeval_0.2.0          magrittr_1.5           
## [35] evaluate_0.10.1         MASS_7.3-45            
## [37] FNN_1.1                 data.table_1.10.4-3    
## [39] tools_3.4.2             stringr_1.2.0          
## [41] munsell_0.4.3           locfit_1.5-9.1         
## [43] cluster_2.0.6           bindrcpp_0.2           
## [45] orthopolynom_1.0-5      compiler_3.4.2         
## [47] caTools_1.17.1          contfrac_1.1-11        
## [49] rlang_0.1.2             grid_3.4.2             
## [51] RCurl_1.95-4.8          igraph_1.1.2           
## [53] bitops_1.0-6            rmarkdown_1.6          
## [55] hypergeo_1.2-13         gtable_0.2.0           
## [57] abind_1.4-5             deSolve_1.20           
## [59] reshape2_1.4.2          R6_2.2.2               
## [61] gridExtra_2.3           dplyr_0.7.4            
## [63] bindr_0.1               rprojroot_1.2          
## [65] KernSmooth_2.23-15      stringi_1.1.5          
## [67] Rcpp_0.12.13</code></pre>

</div>
</div>
<div id="projecting-scrna-seq-data" class="section level2">
<h2><span class="header-section-number">4.8</span> Projecting scRNA-seq data</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scmap)
<span class="kw">library</span>(scater)
<span class="kw">library</span>(SingleCellExperiment)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)</code></pre></div>
<p>As more and more scRNA-seq datasets become available, carrying out comparisons between them is key. A central application is to compare datasets of similar biological origin collected by different labs to ensure that the annotation and the analysis is consistent. Moreover, as very large references, e.g. the Human Cell Atlas (HCA) (<span class="citation">(Regev et al. <a href="#ref-Regev2017-mw">2017</a>)</span>), become available, an important application will be to project cells from a new sample (e.g. from a disease tissue) onto the reference to characterize differences in composition, or to detect new cell-types. Conceptually, such projections are similar to the popular BLAST method (<span class="citation">(Altschul et al. <a href="#ref-Altschul1990-ts">1990</a>)</span>), which makes it possible to quickly find the closest match in a database for a newly identified nucleotide or amino acid sequence.</p>
<p>We recently developed <code>scmap</code> (<span class="citation">(Kiselev and Hemberg <a href="#ref-Kiselev2017-nb">2017</a>)</span>) - a method for projecting cells from a scRNA-seq experiment onto the cell-types identified in other experiments. Additionally, a cloud version of <code>scmap</code> can be run for free, without restrictions, from <a href="http://www.hemberg-lab.cloud/scmap" class="uri">http://www.hemberg-lab.cloud/scmap</a>.</p>
<div id="datasets" class="section level3">
<h3><span class="header-section-number">4.8.1</span> Datasets</h3>
<p>We will run <code>scmap</code> on two human pancreas datasets: Muraro et al. (<span class="citation">(Muraro et al. <a href="#ref-Muraro2016-yk">2016</a>)</span>) and Segerstolpe et al. (<span class="citation">(Segerstolpe et al. <a href="#ref-Segerstolpe2016-wc">2016</a>)</span>). These datasets are well annotated. As usual cell type labels are store in the <code>cell_type1</code> column of the <code>colData</code> slots.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;pancreas/muraro.rds&quot;</span>)
segerstolpe &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;pancreas/segerstolpe.rds&quot;</span>)</code></pre></div>
<p><code>scmap</code> can be used to perform both types of projections to either a single dataset or to a reference collection of datasets (Atlas):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">knitr<span class="op">::</span><span class="kw">include_graphics</span>(<span class="st">&quot;figures/scmap1.png&quot;</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-4"></span>
<img src="figures/scmap1.png" alt="scmap can be used to compare the annotations of two different samples by providing a one to one mapping between the cells." width="80%" />
<p class="caption">
Figure 2.5: scmap can be used to compare the annotations of two different samples by providing a one to one mapping between the cells.
</p>
</div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">knitr<span class="op">::</span><span class="kw">include_graphics</span>(<span class="st">&quot;figures/scmap2.png&quot;</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-5"></span>
<img src="figures/scmap2.png" alt=" scmap can also be used to project cells from a new experiment onto an annotated reference." width="80%" />
<p class="caption">
Figure 2.6:  scmap can also be used to project cells from a new experiment onto an annotated reference.
</p>
</div>
</div>
<div id="run-scmap" class="section level3">
<h3><span class="header-section-number">4.8.2</span> Run <code>scmap</code></h3>
<div id="feature-selection-1" class="section level4">
<h4><span class="header-section-number">4.8.2.1</span> Feature Selection</h4>
<p>Once we have a <code>SingleCellExperiment</code> object we can run <code>scmap</code>. Firstly, we need to select the most informative features from our input dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro &lt;-<span class="st"> </span><span class="kw">getFeatures</span>(muraro, <span class="dt">suppress_plot =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## Warning in linearModel(object, n_features): Your object does not contain
## counts() slot. Dropouts were calculated using logcounts() slot...</code></pre>
<p><img src="24-projection_files/figure-html/unnamed-chunk-6-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Genes highlighted with the red colour will be used in the futher analysis (projection).</p>
</div>
<div id="projecting" class="section level4">
<h4><span class="header-section-number">4.8.2.2</span> Projecting</h4>
<p>We will project the <code>segerstolpe</code> dataset to <code>muraro</code> dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">segerstolpe &lt;-<span class="st"> </span><span class="kw">projectData</span>(<span class="dt">projection =</span> segerstolpe, <span class="dt">reference =</span> muraro)</code></pre></div>
<pre><code>## Warning in setFeatures(projection_local, as.data.frame(rowData(reference))
## $feature_symbol[as.data.frame(rowData(reference))$scmap_features]):
## Features C19orf77, CSDA, LOC100216479 are not present in the &#39;SCESet&#39;
## object and therefore were not set.</code></pre>
<p>In your own analysis you can choose any two scRNASeq datasets and project them to each other. Note that the <code>getFeatures</code> functions has to be run on the reference dataset before running the <code>projectData</code> function.</p>
</div>
</div>
<div id="results" class="section level3">
<h3><span class="header-section-number">4.8.3</span> Results</h3>
<p>Let’s look at the results. The labels produced by <code>scmap</code> are located in the <code>scmap_labs</code> column of the <code>colData</code> slot of the projection dataset. We will compare them to the original labels provided by the authors of the publication:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colData</span>(segerstolpe)[,<span class="kw">c</span>(<span class="st">&quot;scmap_labs&quot;</span>, <span class="st">&quot;scmap_siml&quot;</span>)]</code></pre></div>
<pre><code>## DataFrame with 3514 rows and 2 columns
##                  scmap_labs scmap_siml
##                 &lt;character&gt;  &lt;numeric&gt;
## AZ_A1            unassigned  0.4452916
## AZ_A10           unassigned  0.6571171
## AZ_A11                alpha  0.8016826
## AZ_A12                delta  0.7209766
## AZ_A2                 gamma  0.7448156
## ...                     ...        ...
## HP1526901T2D_P5  unassigned  0.3884353
## HP1526901T2D_P6  unassigned  0.3858811
## HP1526901T2D_P7        beta  0.8698103
## HP1526901T2D_P8  unassigned  0.3668804
## HP1526901T2D_P9        beta  0.8691188</code></pre>
<p>Clearly the projection is almost perfect. With <code>scmap</code> one can also plot a <a href="https://developers.google.com/chart/interactive/docs/gallery/sankey">Sankey diagram</a> (however, <code>cell_type1</code> columns have to be provided in the <code>colData</code> slots of both the reference and the projection datasets):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw">getSankey</span>(<span class="kw">colData</span>(segerstolpe)<span class="op">$</span>cell_type1, <span class="kw">colData</span>(segerstolpe)<span class="op">$</span>scmap_labs))</code></pre></div>
<!-- Sankey generated in R 3.4.2 by googleVis 0.6.2 package -->
<!-- Sat Oct 28 15:41:08 2017 -->
<!-- jsHeader -->
<script type="text/javascript">
 
// jsData 
function gvisDataSankeyID65d332fcd69 () {
var data = new google.visualization.DataTable();
var datajson =
[
 [
"not applicable ",
" unassigned",
998
],
[
"alpha ",
" alpha",
869
],
[
"ductal ",
" ductal",
383
],
[
"beta ",
" beta",
260
],
[
"gamma ",
" gamma",
192
],
[
"acinar ",
" acinar",
181
],
[
"delta ",
" delta",
111
],
[
"PSC ",
" mesenchymal",
53
],
[
"unclassified endocrine ",
" unassigned",
41
],
[
"co-expression ",
" beta",
31
],
[
"endothelial ",
" endothelial",
14
],
[
"mast ",
" unassigned",
7
],
[
"epsilon ",
" epsilon",
6
],
[
"MHC class II ",
" unassigned",
5
],
[
"unclassified ",
" unassigned",
2
],
[
"acinar ",
" ductal",
4
],
[
"alpha ",
" unassigned",
16
],
[
"alpha ",
" beta",
1
],
[
"beta ",
" unassigned",
10
],
[
"co-expression ",
" alpha",
7
],
[
"co-expression ",
" unassigned",
1
],
[
"delta ",
" beta",
1
],
[
"delta ",
" unassigned",
2
],
[
"ductal ",
" unclear",
1
],
[
"ductal ",
" unassigned",
2
],
[
"endothelial ",
" unassigned",
2
],
[
"epsilon ",
" unassigned",
1
],
[
"gamma ",
" alpha",
2
],
[
"gamma ",
" unassigned",
3
],
[
"not applicable ",
" alpha",
161
],
[
"not applicable ",
" acinar",
17
],
[
"not applicable ",
" beta",
16
],
[
"not applicable ",
" ductal",
72
],
[
"not applicable ",
" delta",
9
],
[
"not applicable ",
" mesenchymal",
11
],
[
"not applicable ",
" endothelial",
7
],
[
"not applicable ",
" gamma",
14
],
[
"PSC ",
" beta",
1
] 
];
data.addColumn('string','From');
data.addColumn('string','To');
data.addColumn('number','# of cells');
data.addRows(datajson);
return(data);
}
 
// jsDrawChart
function drawChartSankeyID65d332fcd69() {
var data = gvisDataSankeyID65d332fcd69();
var options = {};
options["width"] = 400;
options["height"] = 600;
options["sankey"] = {
                node:{
                    label:{
                        fontName:'Arial',
                        fontSize:11,color:
                        '#000000',
                        bold:true,
                        italic:false
                    },
                    colors:'#FFFFFF',
                    nodePadding:12
                },iterations:0
            };

    var chart = new google.visualization.Sankey(
    document.getElementById('SankeyID65d332fcd69')
    );
    chart.draw(data,options);
    

}
  
 
// jsDisplayChart
(function() {
var pkgs = window.__gvisPackages = window.__gvisPackages || [];
var callbacks = window.__gvisCallbacks = window.__gvisCallbacks || [];
var chartid = "sankey";
  
// Manually see if chartid is in pkgs (not all browsers support Array.indexOf)
var i, newPackage = true;
for (i = 0; newPackage && i < pkgs.length; i++) {
if (pkgs[i] === chartid)
newPackage = false;
}
if (newPackage)
  pkgs.push(chartid);
  
// Add the drawChart function to the global list of callbacks
callbacks.push(drawChartSankeyID65d332fcd69);
})();
function displayChartSankeyID65d332fcd69() {
  var pkgs = window.__gvisPackages = window.__gvisPackages || [];
  var callbacks = window.__gvisCallbacks = window.__gvisCallbacks || [];
  window.clearTimeout(window.__gvisLoad);
  // The timeout is set to 100 because otherwise the container div we are
  // targeting might not be part of the document yet
  window.__gvisLoad = setTimeout(function() {
  var pkgCount = pkgs.length;
  google.load("visualization", "1", { packages:pkgs, callback: function() {
  if (pkgCount != pkgs.length) {
  // Race condition where another setTimeout call snuck in after us; if
  // that call added a package, we must not shift its callback
  return;
}
while (callbacks.length > 0)
callbacks.shift()();
} });
}, 100);
}
 
// jsFooter
</script>
<!-- jsChart -->
<script type="text/javascript" src="https://www.google.com/jsapi?callback=displayChartSankeyID65d332fcd69"></script>
<!-- divChart -->
<div id="SankeyID65d332fcd69" style="width: 400; height: 600;">

</div>
</div>
<div id="creating-a-precomputed-reference" class="section level3">
<h3><span class="header-section-number">4.8.4</span> Creating a precomputed Reference</h3>
<p>The cell type centroids can be precomputed by using the <code>createReference</code> method:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">reference &lt;-<span class="st"> </span><span class="kw">createReference</span>(muraro[<span class="kw">rowData</span>(muraro)<span class="op">$</span>scmap_features, ])</code></pre></div>
<p>One can also visualise the cell type centroids, e.g.:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">heatmap</span>(<span class="kw">as.matrix</span>(reference))</code></pre></div>
<p><img src="24-projection_files/figure-html/unnamed-chunk-11-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Exactly the same projection as above can be performed by providing the precomputed reference instead of the <code>SingleCellExperiment</code> object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">segerstolpe &lt;-<span class="st"> </span><span class="kw">projectData</span>(<span class="dt">projection =</span> segerstolpe, <span class="dt">reference =</span> reference)</code></pre></div>
<pre><code>## Warning in setFeatures(projection_local, rownames(reference)): Features
## C19orf77, CSDA, LOC100216479 are not present in the &#39;SCESet&#39; object and
## therefore were not set.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colData</span>(segerstolpe)[,<span class="kw">c</span>(<span class="st">&quot;scmap_labs&quot;</span>, <span class="st">&quot;scmap_siml&quot;</span>)]</code></pre></div>
<pre><code>## DataFrame with 3514 rows and 2 columns
##                  scmap_labs scmap_siml
##                 &lt;character&gt;  &lt;numeric&gt;
## AZ_A1            unassigned  0.4452916
## AZ_A10           unassigned  0.6571171
## AZ_A11                alpha  0.8016826
## AZ_A12                delta  0.7209766
## AZ_A2                 gamma  0.7448156
## ...                     ...        ...
## HP1526901T2D_P5  unassigned  0.3884353
## HP1526901T2D_P6  unassigned  0.3858811
## HP1526901T2D_P7        beta  0.8698103
## HP1526901T2D_P8  unassigned  0.3668804
## HP1526901T2D_P9        beta  0.8691188</code></pre>
</div>
<div id="sessioninfo-14" class="section level3">
<h3><span class="header-section-number">4.8.5</span> sessionInfo()</h3>
<pre><code>## R version 3.4.2 (2017-09-28)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS/LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] stats4    parallel  methods   stats     graphics  grDevices utils    
## [8] datasets  base     
## 
## other attached packages:
##  [1] bindrcpp_0.2                scater_1.5.21              
##  [3] SingleCellExperiment_0.99.4 SummarizedExperiment_1.6.5 
##  [5] DelayedArray_0.2.7          matrixStats_0.52.2         
##  [7] GenomicRanges_1.28.6        GenomeInfoDb_1.12.3        
##  [9] IRanges_2.10.5              S4Vectors_0.14.7           
## [11] ggplot2_2.2.1               Biobase_2.36.2             
## [13] BiocGenerics_0.22.1         scmap_0.99.8               
## [15] googleVis_0.6.2             knitr_1.17                 
## 
## loaded via a namespace (and not attached):
##  [1] viridis_0.4.0           edgeR_3.18.1           
##  [3] bit64_0.9-7             jsonlite_1.5           
##  [5] viridisLite_0.2.0       shiny_1.0.5            
##  [7] assertthat_0.2.0        highr_0.6              
##  [9] blob_1.1.0              vipor_0.4.5            
## [11] GenomeInfoDbData_0.99.0 yaml_2.1.14            
## [13] RSQLite_2.0             backports_1.1.1        
## [15] lattice_0.20-34         glue_1.1.1             
## [17] limma_3.32.10           digest_0.6.12          
## [19] XVector_0.16.0          randomForest_4.6-12    
## [21] colorspace_1.3-2        htmltools_0.3.6        
## [23] httpuv_1.3.5            Matrix_1.2-7.1         
## [25] plyr_1.8.4              XML_3.98-1.9           
## [27] pkgconfig_2.0.1         biomaRt_2.32.1         
## [29] bookdown_0.5            zlibbioc_1.22.0        
## [31] xtable_1.8-2            scales_0.5.0           
## [33] tibble_1.3.4            proxy_0.4-17           
## [35] lazyeval_0.2.0          magrittr_1.5           
## [37] mime_0.5                memoise_1.1.0          
## [39] evaluate_0.10.1         class_7.3-14           
## [41] beeswarm_0.2.3          shinydashboard_0.6.1   
## [43] tools_3.4.2             data.table_1.10.4-3    
## [45] stringr_1.2.0           munsell_0.4.3          
## [47] locfit_1.5-9.1          AnnotationDbi_1.38.2   
## [49] compiler_3.4.2          e1071_1.6-8            
## [51] rlang_0.1.2             rhdf5_2.20.0           
## [53] grid_3.4.2              RCurl_1.95-4.8         
## [55] tximport_1.4.0          rjson_0.2.15           
## [57] labeling_0.3            bitops_1.0-6           
## [59] rmarkdown_1.6           gtable_0.2.0           
## [61] codetools_0.2-15        DBI_0.7                
## [63] reshape2_1.4.2          R6_2.2.2               
## [65] gridExtra_2.3           dplyr_0.7.4            
## [67] bit_1.1-12              bindr_0.1              
## [69] rprojroot_1.2           ggbeeswarm_0.6.0       
## [71] stringi_1.1.5           Rcpp_0.12.13</code></pre>

</div>
</div>
<div id="search-scrna-seq-data" class="section level2">
<h2><span class="header-section-number">4.9</span> Search scRNA-Seq data</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(scfind)
<span class="kw">library</span>(SingleCellExperiment)
<span class="kw">set.seed</span>(<span class="dv">1234567</span>)</code></pre></div>
<div id="about" class="section level3">
<h3><span class="header-section-number">4.9.1</span> About</h3>
<p><code>scfind</code> is a tool that allows one to search single cell RNA-Seq collections (Atlas) using lists of genes, e.g. searching for cells and cell-types where a specific set of genes are expressed. <code>scfind</code> is a <a href="http://bioconductor.org/packages/scfind">Bioconductor package</a>. Cloud implementation of <code>scfind</code> with a large collection of datasets is available on our <a href="http://www.hemberg-lab.cloud/scfind">website</a>.</p>
<div class="figure" style="text-align: center"><span id="fig:unnamed-chunk-3"></span>
<img src="figures/scfind.png" alt="scfind can be used to search large collection of scRNA-seq data by a list of gene IDs." width="80%" />
<p class="caption">
Figure 2.4: scfind can be used to search large collection of scRNA-seq data by a list of gene IDs.
</p>
</div>
</div>
<div id="dataset" class="section level3">
<h3><span class="header-section-number">4.9.2</span> Dataset</h3>
<p>We will run <code>scfind</code> on the same human pancreas dataset as in the previous chapter. <code>scfind</code> also operates on <code>SingleCellExperiment</code> class:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">muraro &lt;-<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;pancreas/muraro.rds&quot;</span>)</code></pre></div>
</div>
<div id="gene-index" class="section level3">
<h3><span class="header-section-number">4.9.3</span> Gene Index</h3>
<p>Now we need to create a gene index using our dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cellIndex &lt;-<span class="st"> </span><span class="kw">buildCellIndex</span>(muraro)</code></pre></div>
<p>The gene index contains for each gene indexes of the cells where it is expressed. This is similar to sparcification of the expression matrix. In addition to this the index is also compressed in a way that it can accessed very quickly. We estimated that one can achieve 5-10 compression factor with this method.</p>
<p>By default the <code>cell_type1</code> column of the <code>colData</code> slot of the <code>SingleCellExperiment</code> object is used to define cell types, however it can also be defined manually using the <code>cell_type_column</code> argument of the <code>buildCellTypeIndex</code> function (check <code>?buildCellTypeIndex</code>).</p>
</div>
<div id="marker-genes" class="section level3">
<h3><span class="header-section-number">4.9.4</span> Marker genes</h3>
<p>Now let’s define lists of cell type specific marker genes. We will use the marker genes identified in the original publication, namely in Figure 1:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># these genes are taken from fig. 1</span>
muraro_alpha &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;GCG&quot;</span>, <span class="st">&quot;LOXL4&quot;</span>, <span class="st">&quot;PLCE1&quot;</span>, <span class="st">&quot;IRX2&quot;</span>, <span class="st">&quot;GC&quot;</span>, <span class="st">&quot;KLHL41&quot;</span>, 
                  <span class="st">&quot;CRYBA2&quot;</span>, <span class="st">&quot;TTR&quot;</span>, <span class="st">&quot;TM4SF4&quot;</span>, <span class="st">&quot;RGS4&quot;</span>)
muraro_beta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;INS&quot;</span>, <span class="st">&quot;IAPP&quot;</span>, <span class="st">&quot;MAFA&quot;</span>, <span class="st">&quot;NPTX2&quot;</span>, <span class="st">&quot;DLK1&quot;</span>, <span class="st">&quot;ADCYAP1&quot;</span>, 
                 <span class="st">&quot;PFKFB2&quot;</span>, <span class="st">&quot;PDX1&quot;</span>, <span class="st">&quot;TGFBR3&quot;</span>, <span class="st">&quot;SYT13&quot;</span>)
muraro_gamma &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;PPY&quot;</span>, <span class="st">&quot;SERTM1&quot;</span>, <span class="st">&quot;CARTPT&quot;</span>, <span class="st">&quot;SLITRK6&quot;</span>, <span class="st">&quot;ETV1&quot;</span>, 
                  <span class="st">&quot;THSD7A&quot;</span>, <span class="st">&quot;AQP3&quot;</span>, <span class="st">&quot;ENTPD2&quot;</span>, <span class="st">&quot;PTGFR&quot;</span>, <span class="st">&quot;CHN2&quot;</span>)
muraro_delta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;SST&quot;</span>, <span class="st">&quot;PRG4&quot;</span>, <span class="st">&quot;LEPR&quot;</span>, <span class="st">&quot;RBP4&quot;</span>, <span class="st">&quot;BCHE&quot;</span>, <span class="st">&quot;HHEX&quot;</span>, 
                  <span class="st">&quot;FRZB&quot;</span>, <span class="st">&quot;PCSK1&quot;</span>, <span class="st">&quot;RGS2&quot;</span>, <span class="st">&quot;GABRG2&quot;</span>)</code></pre></div>
</div>
<div id="search-cells-by-a-gene-list" class="section level3">
<h3><span class="header-section-number">4.9.5</span> Search cells by a gene list</h3>
<p><code>findCell</code> function returns a list of p-values corresponding to all cell types in a given dataset. It also outputs a list of cells in which genes from the given gene list are co-expressed. We will run it on all lists of marker genes defined above:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res &lt;-<span class="st"> </span><span class="kw">findCell</span>(cellIndex, muraro_alpha)
<span class="kw">barplot</span>(<span class="op">-</span><span class="kw">log10</span>(res<span class="op">$</span>p_values), <span class="dt">ylab =</span> <span class="st">&quot;-log10(pval)&quot;</span>, <span class="dt">las =</span> <span class="dv">2</span>)</code></pre></div>
<p><img src="25-search_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(res<span class="op">$</span>common_exprs_cells)</code></pre></div>
<pre><code>##   cell_id cell_type
## 1       1     alpha
## 2       3     alpha
## 3       7     alpha
## 4       9     alpha
## 5      15     alpha
## 6      20     alpha</code></pre>
<p><strong>Exercise 1</strong></p>
<p>Perform a search by <em>beta</em>, <em>delta</em> and <em>gamma</em> gene lists and explore the results.</p>
<p><img src="25-search_files/figure-html/unnamed-chunk-8-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id cell_type
## 1      71     alpha
## 2      72      beta
## 3      92      beta
## 4      96      beta
## 5      98      beta
## 6     102      beta</code></pre>
<p><img src="25-search_files/figure-html/unnamed-chunk-8-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id cell_type
## 1      40     delta
## 2     212     delta
## 3     225     delta
## 4     253     delta
## 5     330     delta
## 6     400     delta</code></pre>
<p><img src="25-search_files/figure-html/unnamed-chunk-8-3.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id cell_type
## 1      53     alpha
## 2     102      beta
## 3     255     gamma
## 4     305     gamma
## 5     525     gamma
## 6     662     gamma</code></pre>
<p><strong>Exercise 2</strong></p>
<p>Load the <code>segerstolpe</code> and search it using <em>alpha</em>, <em>beta</em>, <em>delta</em> and <em>gamma</em> gene lists identified in <code>muraro</code> dataset.</p>
<p><img src="25-search_files/figure-html/unnamed-chunk-9-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id cell_type
## 1      18     alpha
## 2      20     alpha
## 3      24     alpha
## 4      32     alpha
## 5      43     alpha
## 6      48     alpha</code></pre>
<p><img src="25-search_files/figure-html/unnamed-chunk-9-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id     cell_type
## 1      15 co-expression
## 2      58          beta
## 3     300          beta
## 4     390 co-expression
## 5     504 co-expression
## 6     506          beta</code></pre>
<p><img src="25-search_files/figure-html/unnamed-chunk-9-3.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id     cell_type
## 1     170         delta
## 2     715         delta
## 3    1039 co-expression
## 4    1133         delta
## 5    1719         delta
## 6    1721         delta</code></pre>
<p><img src="25-search_files/figure-html/unnamed-chunk-9-4.png" width="672" style="display: block; margin: auto;" /></p>
<pre><code>##   cell_id cell_type
## 1      47     gamma
## 2     458     gamma
## 3     476     gamma
## 4     600     gamma
## 5     606     gamma
## 6     622     gamma</code></pre>
</div>
<div id="sessioninfo-15" class="section level3">
<h3><span class="header-section-number">4.9.6</span> sessionInfo()</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sessionInfo</span>()</code></pre></div>
<pre><code>## R version 3.4.2 (2017-09-28)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Debian GNU/Linux 9 (stretch)
## 
## Matrix products: default
## BLAS/LAPACK: /usr/lib/libopenblasp-r0.2.19.so
## 
## locale:
##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=C             
##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
## [1] parallel  stats4    methods   stats     graphics  grDevices utils    
## [8] datasets  base     
## 
## other attached packages:
##  [1] SingleCellExperiment_0.99.4 SummarizedExperiment_1.6.5 
##  [3] DelayedArray_0.2.7          matrixStats_0.52.2         
##  [5] Biobase_2.36.2              GenomicRanges_1.28.6       
##  [7] GenomeInfoDb_1.12.3         IRanges_2.10.5             
##  [9] S4Vectors_0.14.7            BiocGenerics_0.22.1        
## [11] scfind_0.99.6               knitr_1.17                 
## 
## loaded via a namespace (and not attached):
##  [1] Rcpp_0.12.13            highr_0.6              
##  [3] plyr_1.8.4              compiler_3.4.2         
##  [5] XVector_0.16.0          bindr_0.1              
##  [7] bitops_1.0-6            tools_3.4.2            
##  [9] zlibbioc_1.22.0         digest_0.6.12          
## [11] bit_1.1-12              tibble_1.3.4           
## [13] evaluate_0.10.1         lattice_0.20-34        
## [15] pkgconfig_2.0.1         rlang_0.1.2            
## [17] Matrix_1.2-7.1          yaml_2.1.14            
## [19] bindrcpp_0.2            GenomeInfoDbData_0.99.0
## [21] stringr_1.2.0           dplyr_0.7.4            
## [23] rprojroot_1.2           grid_3.4.2             
## [25] glue_1.1.1              R6_2.2.2               
## [27] hash_2.2.6              rmarkdown_1.6          
## [29] bookdown_0.5            reshape2_1.4.2         
## [31] magrittr_1.5            backports_1.1.1        
## [33] htmltools_0.3.6         assertthat_0.2.0       
## [35] stringi_1.1.5           RCurl_1.95-4.8</code></pre>

<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1234567</span>)</code></pre></div>
</div>
</div>
</div>
<h3> References</h3>
<div id="refs" class="references">
<div id="ref-Guo2015-ok">
<p>Guo, Minzhe, Hui Wang, S Steven Potter, Jeffrey A Whitsett, and Yan Xu. 2015. “SINCERA: A Pipeline for Single-Cell RNA-Seq Profiling Analysis.” <em>PLoS Comput. Biol.</em> 11 (11): e1004575.</p>
</div>
<div id="ref-Zurauskiene2016-kg">
<p>Žurauskienė, Justina, and Christopher Yau. 2016. “PcaReduce: Hierarchical Clustering of Single Cell Transcriptional Profiles.” <em>BMC Bioinformatics</em> 17 (22~mar): 140.</p>
</div>
<div id="ref-Kiselev2016-bq">
<p>Kiselev, Vladimir Yu, Kristina Kirschner, Michael T Schaub, Tallulah Andrews, Tamir Chandra, Kedar N Natarajan, Wolf Reik, Mauricio Barahona, Anthony R Green, and Martin Hemberg. 2016. “SC3 - Consensus Clustering of Single-Cell RNA-Seq Data.” <em>bioRxiv</em>.</p>
</div>
<div id="ref-Xu2015-vf">
<p>Xu, Chen, and Zhengchang Su. 2015. “Identification of Cell Types from Single-Cell Transcriptomes Using a Novel Clustering Method.” <em>Bioinformatics</em>, 11~feb.</p>
</div>
<div id="ref-Levine2015-fk">
<p>Levine, Jacob H, Erin F Simonds, Sean C Bendall, Kara L Davis, El-Ad D Amir, Michelle D Tadmor, Oren Litvin, et al. 2015. “Data-Driven Phenotypic Dissection of AML Reveals Progenitor-Like Cells That Correlate with Prognosis.” <em>Cell</em> 162 (1): 184–97.</p>
</div>
<div id="ref-Deng2014-mx">
<p>Deng, Qiaolin, Daniel Ramsköld, Björn Reinius, and Rickard Sandberg. 2014. “Single-Cell RNA-seq Reveals Dynamic, Random Monoallelic Gene Expression in Mammalian Cells.” <em>Science</em> 343 (6167): 193–96.</p>
</div>
<div id="ref-Cannoodt2016-uj">
<p>Cannoodt, Robrecht, Wouter Saelens, and Yvan Saeys. 2016. “Computational methods for trajectory inference from single-cell transcriptomics.” <em>European Journal of Immunology</em> 46 (11): 2496–2506. doi:<a href="https://doi.org/10.1002/eji.201646347">10.1002/eji.201646347</a>.</p>
</div>
<div id="ref-Welch2016-jr">
<p>Welch, Joshua D, Alexander J Hartemink, and Jan F Prins. 2016. “SLICER: inferring branched, nonlinear cellular trajectories from single cell RNA-seq data.” <em>Genome Biology</em> 17 (1): 106. doi:<a href="https://doi.org/10.1186/s13059-016-0975-3">10.1186/s13059-016-0975-3</a>.</p>
</div>
<div id="ref-Van_Dijk2017-bh">
<p>Dijk, David van, Juozas Nainys, Roshan Sharma, Pooja Kathail, Ambrose J Carr, Kevin R Moon, Linas Mazutis, Guy Wolf, Smita Krishnaswamy, and Dana Pe’er. 2017. “MAGIC: A Diffusion-Based Imputation Method Reveals Gene-Gene Interactions in Single-Cell RNA-sequencing Data.” <em>bioRxiv</em>.</p>
</div>
<div id="ref-Li2017-tz">
<p>Li, Wei Vivian, and Jingyi Jessica Li. 2017. “ScImpute: Accurate and Robust Imputation for Single Cell RNA-Seq Data.” <em>bioRxiv</em>.</p>
</div>
<div id="ref-Regev2017-mw">
<p>Regev, Aviv, Sarah Teichmann, Eric S Lander, Ido Amit, Christophe Benoist, Ewan Birney, Bernd Bodenmiller, et al. 2017. “The Human Cell Atlas.” <em>bioRxiv</em>.</p>
</div>
<div id="ref-Altschul1990-ts">
<p>Altschul, S F, W Gish, W Miller, E W Myers, and D J Lipman. 1990. “Basic Local Alignment Search Tool.” <em>J. Mol. Biol.</em> 215 (3): 403–10.</p>
</div>
<div id="ref-Kiselev2017-nb">
<p>Kiselev, Vladimir Yu, and Martin Hemberg. 2017. “Scmap - a Tool for Unsupervised Projection of Single Cell RNA-seq Data.” <em>bioRxiv</em>.</p>
</div>
<div id="ref-Muraro2016-yk">
<p>Muraro, Mauro J, Gitanjali Dharmadhikari, Dominic Grün, Nathalie Groen, Tim Dielen, Erik Jansen, Leon van Gurp, et al. 2016. “A Single-Cell Transcriptome Atlas of the Human Pancreas.” <em>Cell Syst</em> 3 (4): 385–394.e3.</p>
</div>
<div id="ref-Segerstolpe2016-wc">
<p>Segerstolpe, Åsa, Athanasia Palasantza, Pernilla Eliasson, Eva-Marie Andersson, Anne-Christine Andréasson, Xiaoyan Sun, Simone Picelli, et al. 2016. “Single-Cell Transcriptome Profiling of Human Pancreatic Islets in Health and Type 2 Diabetes.” <em>Cell Metab.</em> 24 (4): 593–607.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="construction-of-expression-matrix.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="seurat-chapter.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": ["scRNA-seq-course.pdf"],
"toc": {
"collapse": "section"
},
"search": true
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
